<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WORKFLOW - Recette Bio OS (UI image + IA)</title>
  <style>
    @font-face {
      font-family: "Inter";
      font-style: normal;
      font-weight: 400;
      font-display: swap;
      src: local("Inter"), local("Segoe UI"), local("SF Pro Text"), local("Helvetica Neue"), local("Arial");
    }

    :root{
      --bg:#f4f6f8;
      --panel:#ffffff;
      --stroke:#e6e8ee;
      --stroke-2:#dfe3ea;
      --text:#0f172a;
      --muted:#6b7280;
      --muted-2:#94a3b8;
      --shadow: 0 12px 30px rgba(15, 23, 42, 0.07);
      --radius: 16px;
      --blue:#3b82f6;
      --blue-100:#e8f1ff;
      --green:#22c55e;
      --amber:#f59e0b;
      --purple:#a855f7;
      --red:#ef4444;
      --chip:#f8fafc;

      --col-recipe: 320px;
      --col-op: 240px;
      --col-lib: 300px;
      --col-collapsed: 64px;

      --canvas-h: clamp(680px, calc(100vh - 200px), 1020px);
      --ai-cursor-ms: 260ms;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:"Inter",system-ui,-apple-system,"Segoe UI",sans-serif;
      background: var(--bg);
      color: var(--text);
      overflow-x:hidden;
    }
    body.modalOpen{ overflow: hidden; }

    /* ===== Header ===== */
    .topbar{
      position: sticky;
      top: 0;
      z-index: 40;
      height: 64px;
      background: linear-gradient(#f9fafb, #f8fafc);
      border-bottom: 1px solid var(--stroke);
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 0 22px 0 120px; /* left nav space */
    }
    .brand{
      display:flex;
      align-items:center;
      gap: 10px;
      font-weight: 800;
      letter-spacing: 0.02em;
      color:#0b1224;
    }
    .brand svg{width:28px;height:28px}
    .tabs{
      display:flex;
      align-items:center;
      gap: 10px;
      margin-left: 14px;
    }
    .tab{
      height: 34px;
      display:inline-flex;
      align-items:center;
      gap: 8px;
      padding: 0 12px;
      border-radius: 10px;
      border: 1px solid var(--stroke);
      background:#fff;
      color:#0f172a;
      font-weight: 700;
      cursor:pointer;
      user-select:none;
      box-shadow: 0 1px 0 rgba(15,23,42,0.02);
    }
    .tab.active{
      border-color: rgba(59, 130, 246, 0.5);
      box-shadow: 0 0 0 3px rgba(59,130,246,0.12);
    }
    .tab.plus{
      width: 34px;
      padding: 0;
      justify-content:center;
      font-size: 18px;
    }
    .topRight{
      display:flex;
      align-items:center;
      gap: 10px;
    }
    .timeChip{
      height: 34px;
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 0 12px;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background:#fff;
      box-shadow: 0 2px 10px rgba(15,23,42,0.05);
      font-weight: 800;
      color:#0f172a;
    }
    .timeChip span{
      color: var(--muted);
      font-weight: 800;
      font-size: 12px;
      letter-spacing: 0.02em;
    }

    /* ===== Left capsule nav ===== */
    .capsuleNav{
      position: fixed;
      left: 22px;
      top: 50%;
      transform: translateY(-50%);
      width: 64px;
      height: 680px;
      max-height: calc(100vh - 120px);
      border-radius: 40px;
      background: #fff;
      border: 1px solid var(--stroke);
      box-shadow: var(--shadow);
      padding: 12px 10px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap: 10px;
      z-index: 50;
    }
    .navIconBtn{
      width: 44px;
      height: 44px;
      border-radius: 14px;
      border: 1px solid transparent;
      background: transparent;
      cursor:pointer;
      display:grid;
      place-items:center;
      color: #99a3b5;
      transition: all 0.12s ease;
    }
    .navIconBtn:hover{
      background: #f5f7fb;
      color: #475569;
      border-color: #eef2f7;
    }
    .navIconBtn.active{
      color: var(--blue);
      background: var(--blue-100);
      border-color: rgba(59,130,246,0.25);
    }
    .navIconBtn svg{width:20px;height:20px}
    .navSpacer{flex:1}

    /* ===== Main layout ===== */
    .shell{
      padding: 18px 22px 90px 120px; /* leave nav space */
      display:grid;
      grid-template-columns: var(--col-recipe) var(--col-op) 1fr var(--col-lib);
      gap: 16px;
      align-items:start;
    }

    .panelLabel{display:inline; white-space:nowrap;}
    body.collapseRecipe .recipePanel .recipeTools,
    body.collapseRecipe .recipePanel .list,
    body.collapseRecipe .recipePanel .panelFooter{display:none;}

    body.collapseOp .opPanel .opList,
    body.collapseOp .opPanel .opFooter{display:none;}

    body.collapseLibrary .libraryPanel .libraryBody,
    body.collapseLibrary .libraryPanel .panelFooter{display:none;}

    /* NOTE: `wideCanvas` ne compresse pas les panneaux (Recette/Op/Library).
       Il sert à activer un mode "canvas large" (panneaux en dock). */

    .panel{
      background: var(--panel);
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      min-height: 0;
    }
    .panelHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 14px 14px 10px 14px;
    }
    .panelHeader .left{
      display:flex;
      align-items:center;
      gap: 10px;
      font-weight: 900;
      color:#0f172a;
    }
    .panelHeader .left svg{width:16px;height:16px;color:#94a3b8}
    .panelHeader .right{
      display:flex;
      align-items:center;
      gap: 8px;
    }
    .miniIcon{
      width: 30px; height: 30px;
      border-radius: 10px;
      border: 1px solid var(--stroke);
      background:#fff;
      cursor:pointer;
      color:#94a3b8;
      display:grid;
      place-items:center;
      transition: all 0.12s ease;
    }
    .miniIcon:hover{box-shadow: 0 10px 30px rgba(15,23,42,0.08); transform: translateY(-1px)}
    .miniIcon svg{width:16px;height:16px}
    .btn{
      height: 36px;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background:#fff;
      font-weight: 900;
      color:#0f172a;
      padding: 0 12px;
      display:inline-flex;
      align-items:center;
      gap: 8px;
      cursor:pointer;
      transition: all 0.12s ease;
      user-select:none;
      white-space: nowrap;
    }
    .btn:hover{box-shadow: 0 10px 30px rgba(15,23,42,0.08); transform: translateY(-1px)}
    .btn.dark{
      background:#111827;
      border-color:#111827;
      color:#fff;
    }
    .btn.ghost{
      background: var(--chip);
      border-color: var(--stroke);
      color: #0f172a;
    }

    /* ===== Panels in main grid ===== */
    .leftCol{display:contents}
    .recipeTools{
      padding: 0 14px 12px 14px;
      display:flex;
      flex-direction:column;
      gap: 10px;
    }
    .searchRow{
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 10px 12px;
      border: 1px solid var(--stroke);
      border-radius: 12px;
      background:#f9fafb;
      color:#64748b;
    }
    .searchRow svg{width:16px;height:16px}
    .searchRow input{
      border:none;
      outline:none;
      background:transparent;
      width:100%;
      font-weight: 800;
      color:#0f172a;
    }
    .splitRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .chip{
      height: 36px;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background:#fff;
      padding: 0 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      font-weight: 900;
      color:#0f172a;
    }
    .chip label{
      display:flex;
      align-items:center;
      gap: 8px;
      color:#475569;
      font-weight: 900;
      font-size: 13px;
    }
    .chip input[type="checkbox"]{
      width: 16px;
      height: 16px;
      accent-color: var(--blue);
    }
    .list{
      padding: 0 10px 12px 10px;
      display:flex;
      flex-direction:column;
      gap: 8px;
      max-height: 420px;
      overflow:auto;
    }
    .listItem{
      height: 38px;
      border-radius: 12px;
      border: 1px solid transparent;
      background:#fff;
      padding: 0 10px 0 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      cursor:pointer;
      transition: all 0.12s ease;
      color:#0f172a;
      font-weight: 900;
    }
    .listItem:hover{background:#fbfcfe; border-color:#eef2f7}
    .listItem.active{
      border-color: rgba(59,130,246,0.65);
      box-shadow: 0 0 0 3px rgba(59,130,246,0.12);
    }
    .kebab{
      width: 30px;
      height: 30px;
      border-radius: 10px;
      border: 1px solid var(--stroke);
      background:#fff;
      cursor:pointer;
      display:grid;
      place-items:center;
      color:#94a3b8;
      transition: all 0.12s ease;
      flex: 0 0 auto;
    }
    .kebab:hover{box-shadow: 0 10px 30px rgba(15,23,42,0.08); transform: translateY(-1px)}
    .kebab svg{width:16px;height:16px}
    .panelFooter{
      padding: 12px 14px 14px 14px;
      border-top: 1px solid var(--stroke);
      background: linear-gradient(#fff, #fbfcfe);
    }

    /* ===== Operation panel ===== */
    .opList{
      padding: 0 10px 14px 10px;
      display:flex;
      flex-direction:column;
      gap: 8px;
    }
    .opRow{
      height: 44px;
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background:#fff;
      padding: 0 12px;
      display:flex;
      align-items:center;
      gap: 10px;
      cursor:pointer;
      transition: all 0.12s ease;
      font-weight: 900;
      color:#0f172a;
    }
    .opRow:hover{box-shadow: 0 10px 30px rgba(15,23,42,0.08); transform: translateY(-1px)}
    .opRow.active{
      border-color: rgba(59,130,246,0.6);
      box-shadow: 0 0 0 3px rgba(59,130,246,0.12);
    }
    .opNum{
      width: 26px; height: 26px;
      border-radius: 10px;
      background: #111827;
      color:#fff;
      font-weight: 900;
      display:grid;
      place-items:center;
      font-size: 13px;
    }
    .opRow.active .opNum{background: var(--blue)}
    .opAdd{
      height: 44px;
      border-radius: 14px;
      border: 1px dashed var(--stroke-2);
      background: #fbfcfe;
      padding: 0 12px;
      display:flex;
      align-items:center;
      gap: 10px;
      cursor:pointer;
      color: var(--muted);
      font-weight: 900;
    }
    .opAdd:hover{border-color: rgba(59,130,246,0.5); color: var(--blue)}

    /* ===== Workspace / canvas ===== */
    .workspace{min-height: 0;}
    .workspaceHeader{
      height: 44px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 0 10px 10px 10px;
    }
    .wsTitle{
      display:flex;
      align-items:center;
      gap: 10px;
      font-weight: 900;
      color:#0f172a;
    }
    .previewBtn{
      height: 34px;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background:#fff;
      padding: 0 12px;
      font-weight: 900;
      cursor:pointer;
      display:flex;
      align-items:center;
      gap: 8px;
      transition: all 0.12s ease;
    }
    .previewBtn:hover{box-shadow: 0 10px 30px rgba(15,23,42,0.08); transform: translateY(-1px)}
    .previewBtn svg{width:14px;height:14px;color:#0f172a}

    .canvasFrame{
      position: relative;
      background: #f3f5f8;
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      min-height: var(--canvas-h);
    }
    .canvas{
      position: relative;
      width: 100%;
      height: var(--canvas-h);
      overflow:hidden;
      user-select:none;
    }
    .wires{
      position:absolute;
      inset:0;
      pointer-events:none;
      overflow: visible;
    }
    .nodesLayer{
      position:absolute;
      inset:0;
      transform-origin: 0 0;
    }
    .marquee{
      position:absolute;
      display:none;
      border-radius: 14px;
      border: 2px dashed rgba(59,130,246,0.55);
      background: rgba(59,130,246,0.12);
      box-shadow: 0 10px 30px rgba(15,23,42,0.10);
      pointer-events:none;
      z-index: 12;
    }
    .snapHint{
      position:absolute;
      display:none;
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.88);
      color:#fff;
      font-size: 12px;
      font-weight: 1000;
      letter-spacing: 0.01em;
      box-shadow: 0 18px 54px rgba(15,23,42,0.32);
      transform: translate(-50%, -120%);
      white-space: nowrap;
      pointer-events:none;
      z-index: 16;
    }
    .snapHint.active{display:block;}
    body.handMode .canvas{cursor: grab;}
    .canvas.panning{cursor: grabbing;}
    .node{
      position:absolute;
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 10px 14px;
      min-width: 210px;
      max-width: 270px;
      height: 60px;
      border-radius: 16px;
      background:#fff;
      border: 1px solid var(--stroke);
      box-shadow: 0 10px 24px rgba(15,23,42,0.06);
      cursor: grab;
    }
    body.compactNodes .node{
      gap: 9px;
      padding: 8px 14px;
      min-width: 210px;
      max-width: 270px;
      height: 54px;
      border-radius: 16px;
    }
    body.wireVertical .node{
      padding: 12px 16px;
      min-width: 260px;
      max-width: 360px;
      height: 74px;
    }
    body.wireVertical.compactNodes .node{
      padding: 10px 16px;
      min-width: 260px;
      max-width: 360px;
      height: 66px;
    }
    .node:active{cursor: grabbing}
    .node.selected{
      border-color: rgba(59,130,246,0.75);
      box-shadow: 0 0 0 3px rgba(59,130,246,0.14), 0 10px 24px rgba(15,23,42,0.06);
    }
    .node.snapTarget{
      border-color: rgba(16,185,129,0.82);
      box-shadow: 0 0 0 3px rgba(16,185,129,0.14), 0 10px 24px rgba(15,23,42,0.06);
    }
    .node.aiFlash{
      animation: aiFlash 900ms ease;
    }

    /* ===== Diff Visual Mode ===== */
    body.diffMode .floatingBar { display: none; }
    body.diffMode .handle { display: none; }
    body.diffMode .node { cursor: default; }

    .node.diff-unchanged {
      opacity: 0.35;
      border-color: var(--stroke);
    }
    .node.diff-added {
      border: 3px solid var(--green);
      background: rgba(34,197,94,0.06);
      box-shadow: 0 0 0 4px rgba(34,197,94,0.12), 0 10px 24px rgba(15,23,42,0.06);
      animation: diffPulseGreen 2s ease-in-out infinite;
    }
    .node.diff-removed {
      border: 3px dashed var(--red);
      background: rgba(239,68,68,0.06);
      opacity: 0.6;
      box-shadow: 0 0 0 4px rgba(239,68,68,0.12);
    }
    .node.diff-removed .nodeTitle { text-decoration: line-through; color: var(--red); }
    .node.diff-modified {
      border: 3px solid var(--amber);
      background: rgba(251,191,36,0.06);
      box-shadow: 0 0 0 4px rgba(251,191,36,0.12), 0 10px 24px rgba(15,23,42,0.06);
      animation: diffPulseAmber 2s ease-in-out infinite;
    }
    @keyframes diffPulseGreen {
      0%,100% { box-shadow: 0 0 0 4px rgba(34,197,94,0.12); }
      50%     { box-shadow: 0 0 0 8px rgba(34,197,94,0.20); }
    }
    @keyframes diffPulseAmber {
      0%,100% { box-shadow: 0 0 0 4px rgba(251,191,36,0.12); }
      50%     { box-shadow: 0 0 0 8px rgba(251,191,36,0.20); }
    }

    .diffBadge {
      position: absolute; top: -10px; right: -10px;
      width: 22px; height: 22px; border-radius: 50%;
      display: grid; place-items: center;
      font-size: 12px; font-weight: 900; color: #fff; z-index: 3;
    }
    .diffBadge.added   { background: var(--green); }
    .diffBadge.removed { background: var(--red); }
    .diffBadge.modified{ background: var(--amber); }

    .diffTooltip {
      position: absolute; bottom: -40px; left: 50%; transform: translateX(-50%);
      background: var(--text); color: #fff; padding: 5px 10px; border-radius: 7px;
      font-size: 11px; font-weight: 600; white-space: nowrap; z-index: 10;
      pointer-events: none; opacity: 0; transition: opacity 0.2s;
    }
    .diffTooltip::before {
      content:""; position:absolute; top:-4px; left:50%; transform:translateX(-50%);
      border-left:4px solid transparent; border-right:4px solid transparent; border-bottom:4px solid var(--text);
    }
    .node:hover .diffTooltip { opacity: 1; }

    /* Diff bar (above canvas) */
    .diffBar {
      display: none;
      align-items: center; gap: 14px;
      padding: 10px 18px;
      background: #fff;
      border-bottom: 1px solid var(--stroke);
      border-radius: 14px 14px 0 0;
      font-size: 13px;
    }
    body.diffMode .diffBar { display: flex; }
    .diffPill {
      display: flex; align-items: center; gap: 6px;
      padding: 4px 12px; border-radius: 8px; font-weight: 700; font-size: 12px; border: 2px solid;
    }
    .diffPill.old  { border-color: var(--red); background: rgba(239,68,68,0.06); color: var(--red); }
    .diffPill.new  { border-color: var(--green); background: rgba(34,197,94,0.06); color: #16a34a; }
    .diffArrow { font-size: 18px; color: var(--muted); }
    .diffLegend {
      margin-left: auto; display: flex; gap: 14px; font-size: 11px; font-weight: 600;
    }
    .diffLegend .leg { display: flex; align-items: center; gap: 4px; }
    .diffLegend .dot { width: 10px; height: 10px; border-radius: 3px; }
    .diffLegend .dot.a { background: var(--green); }
    .diffLegend .dot.r { background: var(--red); }
    .diffLegend .dot.m { background: var(--amber); }
    .diffLegend .dot.u { background: #cbd5e1; }

    /* Diff summary floating panel */
    .diffSummary {
      display: none;
      position: absolute; top: 14px; right: 14px;
      width: 270px; background: #fff; border: 1px solid var(--stroke);
      border-radius: 14px; box-shadow: 0 12px 30px rgba(15,23,42,0.1);
      z-index: 20; font-size: 13px; overflow: hidden;
    }
    body.diffMode .diffSummary { display: block; }
    .diffSummary .dsHead {
      padding: 10px 14px; font-weight: 800; font-size: 13px;
      border-bottom: 1px solid var(--stroke);
      display: flex; justify-content: space-between; align-items: center;
    }
    .diffSummary .dsList { padding: 6px 0; max-height: 260px; overflow-y: auto; }
    .diffSummary .dsItem {
      padding: 6px 14px; display: flex; align-items: center; gap: 8px;
      cursor: pointer; transition: background 0.15s;
    }
    .diffSummary .dsItem:hover { background: #f8fafc; }
    .diffSummary .dsIcon {
      width: 22px; height: 22px; border-radius: 6px; display: grid;
      place-items: center; font-size: 11px; font-weight: 900; color: #fff; flex: 0 0 auto;
    }
    .diffSummary .dsIcon.a { background: var(--green); }
    .diffSummary .dsIcon.r { background: var(--red); }
    .diffSummary .dsIcon.m { background: var(--amber); }
    .diffSummary .dsName { font-weight: 700; font-size: 12px; }
    .diffSummary .dsDesc { color: var(--muted); font-size: 11px; }
    .diffSummary .dsStats {
      padding: 8px 14px; border-top: 1px solid var(--stroke);
      display: flex; gap: 12px; font-weight: 700; font-size: 11px;
    }
    .diffSummary .dsStats .sa { color: #16a34a; }
    .diffSummary .dsStats .sr { color: var(--red); }
    .diffSummary .dsStats .sm { color: var(--amber); }

    /* Diff close button in workspace header */
    .diffCloseBtn {
      display: none;
      height: 30px; padding: 0 12px; border-radius: 8px;
      border: 1px solid var(--stroke); background: #fff;
      font-weight: 700; font-size: 12px; cursor: pointer;
      align-items: center; gap: 4px; color: var(--red);
    }
    body.diffMode .diffCloseBtn { display: inline-flex; }
    body.diffMode .previewBtn { display: none; }

    /* Version history items — git timeline */
    .histItem {
      display: flex; align-items: flex-start; gap: 10px;
      padding: 10px 18px 10px 12px;
      cursor: pointer; transition: background 0.15s; position: relative;
    }
    .histItem:hover { background: #f8fafc; }
    .histItem.selected { background: rgba(59,130,246,0.06); }
    .histItem.isCurrent { background: rgba(59,130,246,0.04); }
    .histCheck { margin-top: 4px; accent-color: var(--blue); flex: 0 0 auto; }
    /* Timeline rail: vertical line + dot */
    .histRail {
      display: flex; flex-direction: column; align-items: center;
      width: 14px; flex: 0 0 14px; position: relative; align-self: stretch;
    }
    .histRail::before, .histRail::after {
      content: ""; position: absolute; left: 50%; width: 2px;
      background: var(--stroke); transform: translateX(-50%);
    }
    .histRail::before { top: 0; height: 10px; }
    .histRail::after { top: 24px; bottom: 0; }
    .histItem:first-child .histRail::before { display: none; }
    .histItem:last-child .histRail::after { display: none; }
    .histDot {
      width: 12px; height: 12px; border-radius: 50%; margin-top: 5px; flex: 0 0 auto;
      border: 2.5px solid var(--stroke); background: #fff; position: relative; z-index: 1;
    }
    .histDot.approved { border-color: var(--green); background: var(--green); }
    .histDot.locked { border-color: var(--purple); background: var(--purple); }
    .histDot.draft { border-color: var(--muted-2); background: #fff; }
    .histDot.review { border-color: var(--amber); background: var(--amber); }
    /* Current version ring */
    .histItem.isCurrent .histDot {
      box-shadow: 0 0 0 3px rgba(59,130,246,0.3);
    }
    .histCurrentBadge {
      display: none; font-size: 9px; font-weight: 800; color: var(--blue);
      background: rgba(59,130,246,0.1); padding: 1px 6px; border-radius: 4px;
      margin-left: 4px; text-transform: uppercase; letter-spacing: 0.5px;
    }
    .histItem.isCurrent .histCurrentBadge { display: inline-block; }
    .histBody { flex: 1; min-width: 0; }
    .histVer {
      font-weight: 800; font-size: 13px; display: flex; align-items: center; gap: 8px;
    }
    .histStatus {
      font-size: 10px; font-weight: 700; padding: 2px 8px; border-radius: 6px;
    }
    .histStatus.approved { background: rgba(34,197,94,0.1); color: #16a34a; }
    .histStatus.locked { background: rgba(168,85,247,0.1); color: var(--purple); }
    .histStatus.draft { background: #f1f5f9; color: var(--muted); }
    .histStatus.review { background: rgba(245,158,11,0.1); color: #d97706; }
    .histMsg { font-size: 12px; color: var(--text); margin-top: 2px; }
    .histMeta { font-size: 11px; color: var(--muted); margin-top: 3px; display: flex; gap: 12px; }
    .histAuthor { font-weight: 600; }
    .histActions { margin-left: auto; display: flex; gap: 6px; align-items: flex-start; }
    .histRestoreBtn {
      font-size: 11px; font-weight: 700; padding: 4px 10px; border-radius: 6px;
      border: 1px solid var(--stroke); background: #fff; cursor: pointer;
      opacity: 0; transition: opacity 0.15s;
    }
    .histItem:hover .histRestoreBtn { opacity: 1; }
    @keyframes aiFlash{
      0%{ box-shadow: 0 0 0 0 rgba(59,130,246,0.0), 0 10px 24px rgba(15,23,42,0.06); transform: translateY(0); }
      35%{ box-shadow: 0 0 0 7px rgba(59,130,246,0.20), 0 18px 44px rgba(15,23,42,0.10); transform: translateY(-1px); }
      100%{ box-shadow: 0 0 0 0 rgba(59,130,246,0.0), 0 10px 24px rgba(15,23,42,0.06); transform: translateY(0); }
    }
    .aiCursor{
      position:absolute;
      left:0;
      top:0;
      width: 14px;
      height: 14px;
      border-radius: 999px;
      background: linear-gradient(135deg, #22c55e, #0ea5e9);
      box-shadow: 0 0 0 8px rgba(14,165,233,0.14), 0 18px 54px rgba(14,165,233,0.30);
      pointer-events:none;
      opacity: 0;
      transform: translate(-999px, -999px);
      transition: transform var(--ai-cursor-ms) cubic-bezier(.2,.9,.2,1), opacity 160ms ease;
      z-index: 18;
    }
    .aiCursor.active{opacity: 1}
    .nodeIcon{
      width: 34px;
      height: 34px;
      border-radius: 10px;
      display:grid;
      place-items:center;
      color:#fff;
      font-weight: 1000;
      flex: 0 0 auto;
    }
    body.compactNodes .nodeIcon{
      width: 32px;
      height: 32px;
      border-radius: 10px;
      font-size: 14px;
    }
    .nodeText{min-width: 0}
    .nodeTitle{
      font-weight: 1000;
      color:#0f172a;
      font-size: 14px;
      line-height: 1.1;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    body.compactNodes .nodeTitle{font-size: 13px}
    .nodeSub{
      font-weight: 900;
      color: var(--muted);
      font-size: 12px;
      margin-top: 3px;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    body.compactNodes .nodeSub{font-size: 11px; margin-top: 2px}
    body.wireVertical .nodeSub{
      white-space: normal;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      margin-top: 2px;
    }
    .handle{
      position:absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 12px; height: 12px;
      border-radius: 50%;
      background:#fff;
      border: 2px solid #d4d9e3;
      box-shadow: 0 6px 14px rgba(15,23,42,0.16);
    }
    body.compactNodes .handle{width: 10px; height: 10px; border-width: 2px}
    body.compactNodes .handle.out{right: -6px}
    body.compactNodes .handle.in{left: -6px}
    .handle.out{right: -7px}
    .handle.in{left: -7px}
    .handle[data-disabled="true"]{opacity:0; pointer-events:none; box-shadow:none}

    /* When using vertical layout, place connection handles top/bottom */
    body.wireVertical .handle{
      top: auto;
      right: auto;
      bottom: auto;
      left: 50%;
      transform: translateX(-50%);
    }
    body.wireVertical .handle.in{top: -10px}
    body.wireVertical .handle.out{bottom: -10px}

    body.wireVertical.compactNodes .handle.in{top: -9px}
    body.wireVertical.compactNodes .handle.out{bottom: -9px}

    .floatingBar{
      position:absolute;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background:#fff;
      box-shadow: var(--shadow);
      z-index: 10;
    }
    .barBtn{
      width: 38px;
      height: 38px;
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background:#fff;
      cursor:pointer;
      display:grid;
      place-items:center;
      transition: all 0.12s ease;
      color:#64748b;
    }
    .barBtn.active{
      background: var(--blue-100);
      border-color: rgba(59,130,246,0.28);
      color: var(--blue);
    }
    .barBtn:hover{box-shadow: 0 10px 30px rgba(15,23,42,0.08); transform: translateY(-1px); color:#0f172a}
    .barBtn svg{width:18px;height:18px}

    /* ===== Library ===== */
    .libraryBody{
      padding: 0 10px 12px 10px;
      display:flex;
      flex-direction:column;
      gap: 10px;
    }
    .libItem{
      height: 46px;
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background:#fff;
      padding: 0 12px;
      display:flex;
      align-items:center;
      gap: 12px;
      cursor: grab;
      user-select:none;
      transition: all 0.12s ease;
    }
    .libItem:hover{box-shadow: 0 10px 30px rgba(15,23,42,0.08); transform: translateY(-1px)}
    .libIcon{
      width: 28px;
      height: 28px;
      border-radius: 8px;
      display:grid;
      place-items:center;
      color:#fff;
      font-weight: 1000;
      flex: 0 0 auto;
    }
    .libLabel{font-weight: 1000; color:#0f172a}
    .libItem small{color: var(--muted); font-weight: 900}

    /* ===== AI drawer ===== */
    .drawer{
      position: fixed;
      right: 22px;
      top: 82px;
      width: 360px;
      height: calc(100vh - 110px);
      background:#fff;
      border: 1px solid var(--stroke);
      border-radius: 18px;
      box-shadow: 0 22px 60px rgba(15,23,42,0.18);
      display:none;
      flex-direction:column;
      overflow:hidden;
      z-index: 60;
    }
    .drawer.active{display:flex}
    .drawerHead{
      padding: 14px 14px 12px 14px;
      border-bottom: 1px solid var(--stroke);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }
    .drawerTitle{
      display:flex;
      align-items:center;
      gap: 10px;
      font-weight: 1000;
      color:#0f172a;
    }
    .drawerTitle .spark{
      width: 28px; height: 28px;
      border-radius: 10px;
      background: linear-gradient(135deg, #111827, #0ea5e9);
      box-shadow: 0 10px 28px rgba(14,165,233,0.26);
      display:grid;
      place-items:center;
      color:#fff;
      font-weight: 1000;
    }
    .drawerBody{
      padding: 12px 14px;
      display:flex;
      flex-direction:column;
      gap: 10px;
      overflow:auto;
      min-height: 0;
    }
    .aiModeBar{
      position: sticky;
      top: 0;
      z-index: 2;
      display:flex;
      gap: 8px;
      padding: 6px;
      border-radius: 16px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,0.92);
      backdrop-filter: blur(10px);
    }
    .aiModeBtn{
      flex: 1 1 auto;
      height: 34px;
      border-radius: 12px;
      border: 1px solid transparent;
      background: transparent;
      font-weight: 1000;
      color: var(--muted);
      cursor:pointer;
      transition: all 0.12s ease;
    }
    .aiModeBtn:hover{background:#fff; border-color: rgba(148,163,184,0.35); color:#0f172a}
    .aiModeBtn.active{
      background:#fff;
      border-color: rgba(59,130,246,0.28);
      color:#0f172a;
      box-shadow: 0 10px 30px rgba(15,23,42,0.08);
    }
    .aiView{display:none; flex-direction:column; gap: 10px;}
    .aiView.active{display:flex;}
    .aiGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .aiGrid.oneCol{grid-template-columns: 1fr}
    .aiAction{
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background:#fbfcfe;
      padding: 10px 12px;
      cursor:pointer;
      transition: all 0.12s ease;
      font-weight: 1000;
      color:#0f172a;
      text-align:left;
    }
    .aiAction:hover{box-shadow: 0 10px 30px rgba(15,23,42,0.08); transform: translateY(-1px); background:#fff}
    .aiAction:disabled{opacity:0.55; cursor:not-allowed; box-shadow:none; transform:none}
    .aiOut{
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background:#fff;
      padding: 12px;
      min-height: 160px;
      font-size: 13px;
      line-height: 1.55;
      color:#0f172a;
      white-space: pre-line;
    }
    .aiPlanWrap{
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background:#fff;
      padding: 10px;
      display:flex;
      flex-direction:column;
      gap: 8px;
    }
    .aiPlanHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }
    .aiPlan{
      display:flex;
      flex-direction:column;
      gap: 8px;
      max-height: 220px;
      overflow:auto;
      padding-right: 4px;
    }
    .aiPlanItem{
      display:grid;
      grid-template-columns: auto 1fr auto;
      gap: 10px;
      align-items:center;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background: var(--chip);
      color:#0f172a;
      font-size: 12px;
      font-weight: 1000;
      cursor: default;
    }
    .aiPlanItem.active{
      background:#fff;
      border-color: rgba(59,130,246,0.45);
      box-shadow: 0 10px 30px rgba(15,23,42,0.08);
    }
    .aiPlanNum{
      width: 22px;
      height: 22px;
      border-radius: 8px;
      background:#111827;
      color:#fff;
      display:grid;
      place-items:center;
      font-weight: 1000;
      font-size: 11px;
    }
    .aiPlanMeta{color: var(--muted); font-weight: 950; font-size: 11px; margin-top: 2px;}
    .aiAsk{
      display:grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items:center;
    }
    .aiAsk input{
      height: 40px;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background:#fff;
      padding: 0 12px;
      outline:none;
      font-weight: 900;
      color:#0f172a;
    }
    .aiAsk button{
      height: 40px;
      border-radius: 12px;
      border: 1px solid #0ea5e9;
      background: linear-gradient(135deg, #111827, #0ea5e9);
      color:#fff;
      font-weight: 1000;
      padding: 0 12px;
      cursor:pointer;
    }
    .aiHint{
      font-size: 12px;
      color: var(--muted);
      font-weight: 900;
    }
    .aiDetails{
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background:#fff;
      padding: 10px;
    }
    .aiDetails summary{
      list-style: none;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      cursor:pointer;
      font-weight: 1000;
      color:#0f172a;
    }
    .aiDetails summary::-webkit-details-marker{display:none}
    .aiDetails summary small{color: var(--muted); font-weight: 900;}
    .aiDetails[open] summary{margin-bottom: 10px;}
    .aiRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }
    .aiRow select{
      height: 34px;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background:#fff;
      padding: 0 10px;
      outline:none;
      font-weight: 900;
      color:#0f172a;
    }
    .aiFooter{
      padding: 12px 14px;
      border-top: 1px solid var(--stroke);
      display:flex;
      gap: 10px;
      justify-content:flex-end;
      background: linear-gradient(#fff, #fbfcfe);
    }

    /* ===== Modal editor ===== */
    .modalBackdrop{
      position: fixed;
      inset: 0;
      background: rgba(15,23,42,0.42);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
      z-index: 80;
      overscroll-behavior: contain;
    }
    .modalBackdrop.active{display:flex}
    .modal{
      width: min(760px, 100%);
      background:#fff;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 24px 80px rgba(15,23,42,0.35);
      overflow:hidden;
    }
    .modalHead{
      padding: 14px 16px;
      border-bottom: 1px solid var(--stroke);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }
    .modalHead .title{
      font-weight: 1000;
      color:#0f172a;
      display:flex;
      align-items:center;
      gap: 10px;
    }
    .modalBody{
      padding: 14px 16px 16px 16px;
      display:grid;
      grid-template-columns: 1.2fr 1fr;
      gap: 14px;
    }
    .field{
      display:flex;
      flex-direction:column;
      gap: 8px;
    }
    .field label{
      font-size: 12px;
      font-weight: 1000;
      color:#475569;
    }
    .field input, .field select, .field textarea{
      border-radius: 12px;
      border: 1px solid var(--stroke);
      padding: 10px 12px;
      font-weight: 900;
      outline:none;
      color:#0f172a;
      background:#fff;
    }
    .field textarea{min-height: 98px; resize: vertical; font-weight: 800}
    .stack{
      display:flex;
      flex-direction:column;
      gap: 10px;
    }
    .tagRow{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
    }
    .tag{
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background:#fbfcfe;
      font-size: 12px;
      font-weight: 1000;
      color:#0f172a;
      display:flex;
      align-items:center;
      gap: 8px;
    }
    .tag button{
      border:none;
      background:transparent;
      cursor:pointer;
      color: var(--muted);
      font-weight: 1000;
    }
    .varChips{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
      margin-top: 8px;
    }
    .varChip{
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: var(--chip);
      font-size: 12px;
      font-weight: 1000;
      color:#0f172a;
      cursor:pointer;
      user-select:none;
      transition: all 0.12s ease;
    }
    .varChip:hover{background:#fff; box-shadow: 0 10px 30px rgba(15,23,42,0.08); transform: translateY(-1px)}
    .varChip.muted{color: var(--muted)}
    .modalFoot{
      padding: 12px 16px;
      border-top: 1px solid var(--stroke);
      display:flex;
      justify-content:flex-end;
      gap: 10px;
      background: linear-gradient(#fff, #fbfcfe);
    }

    /* ===== Select variable modal (MFCS-like, demo) ===== */
    .varModal{
      width: min(820px, 100%);
    }
    .varWrap{
      padding: 14px 16px 16px 16px;
      display:flex;
      flex-direction:column;
      gap: 12px;
    }
    .varToolbar{
      display:flex;
      gap: 10px;
      align-items:center;
    }
    .varToolbar input{
      flex:1;
      height: 38px;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background:#fff;
      padding: 0 12px;
      outline:none;
      font-weight: 900;
      color:#0f172a;
    }
    .varList{
      border: 1px solid var(--stroke);
      border-radius: 16px;
      overflow:hidden;
      background:#fff;
      max-height: 380px;
      overflow:auto;
    }
    .varRow{
      display:grid;
      grid-template-columns: 1fr auto auto;
      gap: 10px;
      align-items:center;
      padding: 10px 12px;
      border-bottom: 1px solid var(--stroke);
      cursor:pointer;
    }
    .varRow:last-child{border-bottom:none}
    .varRow:hover{background:#f8fafc}
    .varRow.selected{
      background: var(--blue-100);
      box-shadow: inset 3px 0 0 rgba(59,130,246,0.95);
    }
    .varRow.disabled{opacity:0.55; cursor:not-allowed; background:#fff;}
    .varList:focus{
      outline: 2px solid rgba(59,130,246,0.35);
      outline-offset: 2px;
    }
    .varName{
      font-weight: 1000;
      color:#0f172a;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .varMeta{
      color: var(--muted);
      font-weight: 900;
      font-size: 12px;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .varPill{
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: var(--chip);
      font-weight: 1000;
      font-size: 11px;
      color:#0f172a;
    }

    /* ===== Formula editor (MFCS-like) ===== */
    .fxModal{
      width: min(980px, 100%);
    }
    .fxWrap{
      padding: 14px 16px 16px 16px;
      display:flex;
      flex-direction:column;
      gap: 14px;
      max-height: min(78vh, 760px);
      overflow:auto;
    }
    .fxTop{
      display:grid;
      grid-template-columns: 320px 1fr;
      gap: 14px;
      align-items:start;
    }
    .fxMeta{
      border: 1px solid var(--stroke);
      border-radius: 14px;
      padding: 12px;
      background: linear-gradient(#fff, #fbfcfe);
      display:flex;
      flex-direction:column;
      gap: 10px;
      min-height: 160px;
    }
    .fxMetaTitle{
      font-weight: 1000;
      color:#0f172a;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }
    .fxMetaTitle small{color: var(--muted); font-weight: 950;}
    .fxMetaHint{
      font-size: 12px;
      font-weight: 900;
      color: var(--muted);
      line-height: 1.45;
    }
    .fxInput{
      border: 1px solid var(--stroke);
      border-radius: 14px;
      padding: 12px;
      background:#fff;
      display:flex;
      flex-direction:column;
      gap: 10px;
      min-height: 160px;
    }
    .fxLabelRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }
    .fxLabelRow label{
      font-size: 12px;
      font-weight: 1000;
      color:#475569;
    }
    .fxText{
      border-radius: 12px;
      border: 1px solid var(--stroke);
      padding: 10px 12px;
      font-weight: 900;
      outline:none;
      color:#0f172a;
      background:#fff;
      min-height: 86px;
      resize: vertical;
    }
    .fxPreview{
      font-size: 12px;
      font-weight: 950;
      color: var(--muted);
      white-space: pre-line;
      line-height: 1.45;
    }
    .fxPad{
      border: 1px solid var(--stroke);
      border-radius: 16px;
      padding: 12px;
      background: #f8fafc;
      display:grid;
      grid-template-columns: 1.25fr 1.1fr 1fr 260px;
      gap: 12px;
      align-items:start;
    }
    .fxGroup{
      display:flex;
      flex-direction:column;
      gap: 10px;
      min-width: 0;
    }
    .fxGroupTitle{
      font-size: 11px;
      font-weight: 1000;
      color:#64748b;
      letter-spacing: 0.06em;
    }
    .fxSearch{
      height: 36px;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background:#fff;
      padding: 0 12px;
      outline:none;
      font-weight: 900;
      color:#0f172a;
    }
    .fxBtns{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
      align-items:center;
    }
    .fxBtn{
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background:#fff;
      font-size: 12px;
      font-weight: 1000;
      color:#0f172a;
      cursor:pointer;
      user-select:none;
      transition: all 0.12s ease;
      white-space: nowrap;
      max-width: 100%;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .fxBtn:hover{box-shadow: 0 10px 30px rgba(15,23,42,0.10); transform: translateY(-1px)}
    .fxBtn.muted{color: var(--muted); background: #f8fafc;}
    .fxNumGrid{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      align-items:stretch;
    }
    .fxNumGrid .fxKey{
      height: 40px;
      border-radius: 12px;
      border: 1px solid var(--stroke);
      background:#fff;
      font-weight: 1000;
      color:#0f172a;
      cursor:pointer;
      transition: all 0.12s ease;
    }
    .fxNumGrid .fxKey:hover{box-shadow: 0 10px 30px rgba(15,23,42,0.10); transform: translateY(-1px)}
    .fxNumGrid .fxKey.danger{border-color: rgba(239,68,68,0.35); color: #b91c1c; background: #fff;}
    .fxNumGrid .fxKey.wide{grid-column: span 2;}
    @media (max-width: 980px){
      .fxTop{grid-template-columns: 1fr;}
      .fxPad{grid-template-columns: 1fr; }
      .fxModal{width: min(760px, 100%);}
    }

    /* ===== Responsiveness ===== */
    @media (max-width: 1160px){
      .shell{grid-template-columns: var(--col-recipe) var(--col-op) 1fr; padding-right: 22px}
      .rightCol{display:none}
      .topbar{padding-right: 22px}
      .drawer{right: 22px}
    }
    @media (max-width: 880px){
      .shell{grid-template-columns: 1fr; padding: 18px 22px 90px 22px}
      .recipePanel,.opPanel{display:none}
      .topbar{padding-left: 22px}
      .capsuleNav{display:none}
    }

    /* ===== Canvas large (dock) ===== */
    body.wideCanvas .shell{
      grid-template-columns: 1fr;
      padding-right: 22px;
    }
    body.wideCanvas .leftCol,
    body.wideCanvas .rightCol{display:none;}
    body.wideCanvas .workspace{grid-column: 1 / -1;}

    /* Dock buttons (visibles uniquement en mode canvas large) */
    .dockRow{
      position:absolute;
      top: 12px;
      left: 12px;
      right: 12px;
      display:none;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      pointer-events:none;
      z-index: 14;
    }
    body.wideCanvas .dockRow{display:flex;}
    .dockGroup{
      display:flex;
      align-items:center;
      gap: 12px;
      pointer-events:auto;
    }
    .dockBtn{
      height: 40px;
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background:#fff;
      box-shadow: 0 10px 30px rgba(15,23,42,0.08);
      padding: 0 12px;
      display:inline-flex;
      align-items:center;
      gap: 10px;
      font-weight: 1000;
      color:#0f172a;
      cursor:pointer;
      user-select:none;
      transition: all 0.12s ease;
      max-width: min(240px, 46vw);
    }
    .dockBtn:hover{transform: translateY(-1px); box-shadow: 0 14px 38px rgba(15,23,42,0.10);}
    .dockBtn.active{
      border-color: rgba(59,130,246,0.65);
      box-shadow: 0 0 0 3px rgba(59,130,246,0.12), 0 14px 38px rgba(15,23,42,0.10);
    }
    .dockBtn svg{width:16px;height:16px;color:#94a3b8;flex: 0 0 auto;}
    .dockBtn .dockLabel{white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}

    /* Dock panels (survol du canvas, ne réduit pas la zone) */
    .dockPanelWrap{
      position:absolute;
      top: 58px;
      left: 12px;
      width: 320px;
      max-height: calc(100% - 74px);
      display:none;
      z-index: 15;
      pointer-events:auto;
    }
    .dockPanelWrap.op{width: 260px;}
    .dockPanelWrap.right{left:auto; right:12px; width: 300px;}
    .dockPanelWrap.open{display:block;}
    .dockPanelWrap .panel{height: 100%;}
  </style>
</head>
<body>
  <!-- Left capsule nav -->
  <nav class="capsuleNav" aria-label="Navigation">
    <button class="navIconBtn" title="Accueil" aria-label="Accueil">
      <svg viewBox="0 0 24 24" fill="none"><path d="M4 11.4 12 4l8 7.4V20a1.5 1.5 0 0 1-1.5 1.5H5.5A1.5 1.5 0 0 1 4 20v-8.6Z" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/></svg>
    </button>
    <button class="navIconBtn" title="Recettes" aria-label="Recettes">
      <svg viewBox="0 0 24 24" fill="none"><path d="M7 7h10M7 12h10M7 17h7" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
    </button>
    <button class="navIconBtn active" title="Workflow" aria-label="Workflow">
      <svg viewBox="0 0 24 24" fill="none"><path d="M6 7h5v5H6V7Zm7 0h5v5h-5V7ZM6 14h5v5H6v-5Zm7 3h5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
    </button>
    <button class="navIconBtn" title="Analytique" aria-label="Analytique">
      <svg viewBox="0 0 24 24" fill="none"><path d="M5 19V9m6 10V5m6 14v-7" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
    </button>
    <div class="navSpacer"></div>
    <button class="navIconBtn" title="Réglages" aria-label="Réglages">
      <svg viewBox="0 0 24 24" fill="none"><path d="M12 15.3a3.3 3.3 0 1 0 0-6.6 3.3 3.3 0 0 0 0 6.6Z" stroke="currentColor" stroke-width="2"/><path d="M19.4 15.1 21 12l-1.6-3.1-2.1.4a7.7 7.7 0 0 0-1.2-1.2l.4-2.1L12 3 8.9 4.6l.4 2.1c-.44.35-.83.75-1.2 1.2l-2.1-.4L3 12l1.6 3.1 2.1-.4c.35.44.75.83 1.2 1.2l-.4 2.1L12 21l3.1-1.6-.4-2.1c.44-.35.83-.75 1.2-1.2l2.1.4Z" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/></svg>
    </button>
  </nav>

  <!-- Top header -->
  <header class="topbar">
    <div style="display:flex;align-items:center;gap:14px;">
      <div class="brand">
        <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M4 12c3.5-6 6.5 6 10 0s6.5 6 6.5 6" stroke="#3b82f6" stroke-width="3" stroke-linecap="round"/>
        </svg>
        WORKFLOW
      </div>
      <div class="tabs" role="tablist" aria-label="Sélecteur de ligne">
        <button class="tab active" role="tab" aria-selected="true"><span style="width:8px;height:8px;border-radius:99px;background:var(--blue);display:inline-block;"></span> BioCat L1-1</button>
        <button class="tab" role="tab" aria-selected="false">L1-2</button>
        <button class="tab plus" title="Ajouter" aria-label="Ajouter">+</button>
      </div>
    </div>
    <div class="topRight">
      <button class="btn ghost" id="openAI" title="Assistant IA">IA</button>
      <div class="timeChip"><strong>9/18/16</strong><span>00h30m</span></div>
    </div>
  </header>

  <main class="shell">
    <!-- Left column -->
    <div class="leftCol">
      <!-- Recipe panel -->
      <section class="panel recipePanel" aria-label="Recette">
        <div class="panelHeader">
          <div class="left">
            <svg viewBox="0 0 24 24" fill="none"><path d="M10.5 18a7.5 7.5 0 1 1 0-15 7.5 7.5 0 0 1 0 15Z" stroke="currentColor" stroke-width="2"/><path d="M21 21l-4.4-4.4" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
            <span class="panelLabel">Recette</span>
          </div>
          <div class="right">
            <button class="miniIcon" data-collapse="recipe" title="Réduire / agrandir" aria-label="Réduire / agrandir"><svg viewBox="0 0 24 24" fill="none"><path d="M6 12h12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg></button>
          </div>
        </div>
        <div class="recipeTools">
          <button class="btn dark" id="newRecipeBtn" style="width:100%;justify-content:center;">New Recipe <span style="opacity:0.9;">+</span></button>
          <div class="splitRow">
            <div class="chip">
              <label><input type="checkbox" id="checkMode" /> Cases à cocher</label>
              <span></span>
            </div>
            <button class="btn ghost" style="justify-content:center;">Filter <span style="color:var(--muted);">▾</span></button>
          </div>
          <div class="searchRow">
            <svg viewBox="0 0 24 24" fill="none"><path d="M10.5 18a7.5 7.5 0 1 1 0-15 7.5 7.5 0 0 1 0 15Z" stroke="currentColor" stroke-width="2"/><path d="M21 21l-4.4-4.4" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
            <input id="recipeSearch" type="search" placeholder="Recette" />
          </div>
        </div>
        <div class="list" id="recipeList" role="listbox" aria-label="Liste de recettes"></div>
        <div class="panelFooter">
          <button class="btn ghost" style="width:100%;justify-content:center;gap:10px;">
            <svg viewBox="0 0 24 24" fill="none" style="width:16px;height:16px;"><path d="M12 3v12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M7 10l5 5 5-5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M4 21h16" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
            Import Recipe
          </button>
        </div>
      </section>

      <!-- Operation panel -->
      <section class="panel opPanel" aria-label="Operation">
        <div class="panelHeader">
          <div class="left">
            <svg viewBox="0 0 24 24" fill="none"><path d="M7 7h10M7 12h10M7 17h10" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
            <span class="panelLabel">Operation</span>
          </div>
          <div class="right">
            <button class="miniIcon" data-collapse="op" title="Réduire / agrandir" aria-label="Réduire / agrandir"><svg viewBox="0 0 24 24" fill="none"><path d="M6 12h12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg></button>
          </div>
        </div>
        <div class="opList" id="operationList" aria-label="Liste d'opérations"></div>
        <div class="opFooter" style="padding: 0 10px 14px 10px;">
          <div class="opAdd" id="addOperationBtn">
            <span style="width:26px;height:26px;border-radius:10px;border:1px dashed var(--stroke-2);display:grid;place-items:center;">+</span>
            Ajouter une opération
          </div>
        </div>
      </section>
    </div>

    <!-- Workspace -->
    <section class="workspace" aria-label="Canvas">
      <div class="workspaceHeader">
        <div class="wsTitle"><span id="wsIndex">1.</span> <span id="wsName">Preparation</span></div>
        <button class="previewBtn" id="previewBtn">
          <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M8 5v14l12-7-12-7Z"/></svg>
          Aperçu
        </button>
        <button class="previewBtn" id="diffBtn" title="Comparer versions" style="background:transparent;border:1px solid var(--stroke);color:var(--text);">
          <svg viewBox="0 0 24 24" fill="none" style="width:16px;height:16px;"><path d="M12 3v18M3 12h18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M8 8L4 12l4 4" stroke="var(--red)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16 8l4 4-4 4" stroke="var(--green)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
          Diff
        </button>
        <button class="diffCloseBtn" id="diffCloseBtn">Fermer le diff</button>
      </div>
      <div class="canvasFrame">
        <!-- Dock (visible en mode "canvas large") -->
        <div class="dockRow" id="dockRow" aria-label="Panneaux (dock)">
          <div class="dockGroup">
            <button class="dockBtn" data-dock="recipe" aria-pressed="false" title="Recette">
              <svg viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M7 7h10M7 12h10M7 17h7" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
              <span class="dockLabel">Recette</span>
            </button>
            <button class="dockBtn" data-dock="op" aria-pressed="false" title="Operation">
              <svg viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M7 7h10M7 12h10M7 17h10" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
              <span class="dockLabel">Operation</span>
            </button>
          </div>
          <div class="dockGroup">
            <button class="dockBtn" data-dock="library" aria-pressed="false" title="Library">
              <svg viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M5 6h14M5 12h14M5 18h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
              <span class="dockLabel">Library</span>
            </button>
          </div>
        </div>
        <div class="dockPanelWrap" id="dockRecipeWrap" aria-hidden="true"></div>
        <div class="dockPanelWrap op" id="dockOpWrap" aria-hidden="true"></div>
        <div class="dockPanelWrap right" id="dockLibraryWrap" aria-hidden="true"></div>
        <!-- Diff bar -->
        <div class="diffBar" id="diffBar">
          <div class="diffPill old"><span id="diffOldLabel">v1</span></div>
          <span class="diffArrow">&rarr;</span>
          <div class="diffPill new"><span id="diffNewLabel">v2</span></div>
          <div class="diffLegend">
            <div class="leg"><div class="dot a"></div> Ajout</div>
            <div class="leg"><div class="dot r"></div> Supprim</div>
            <div class="leg"><div class="dot m"></div> Modifi</div>
            <div class="leg"><div class="dot u"></div> Inchang</div>
          </div>
        </div>
        <div class="canvas" id="canvas">
          <svg class="wires" id="wires"></svg>
          <div class="nodesLayer" id="nodesLayer" aria-hidden="true"></div>
          <div class="marquee" id="marquee" aria-hidden="true"></div>
          <div class="snapHint" id="snapHint" aria-hidden="true"></div>
          <!-- Diff summary panel -->
          <div class="diffSummary" id="diffSummary">
            <div class="dsHead">
              <span>Changements</span>
              <span id="diffSummaryOp" style="font-size:11px;color:var(--muted);"></span>
            </div>
            <div class="dsList" id="diffSummaryList"></div>
            <div class="dsStats" id="diffSummaryStats"></div>
          </div>
        </div>
        <div class="floatingBar">
          <button class="barBtn" id="toolHand" title="Déplacer / sélectionner" aria-label="Déplacer / sélectionner">
            <svg viewBox="0 0 24 24" fill="none"><path d="M7 13V7a1.5 1.5 0 0 1 3 0v5" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M10 12V6a1.5 1.5 0 0 1 3 0v6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M13 12V8a1.5 1.5 0 1 1 3 0v6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M16 13v-2a1.5 1.5 0 1 1 3 0v4c0 3-2 6-5 6H11c-2 0-3-1-4-3l-1-2a1.8 1.8 0 0 1 3-2l1 1" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </button>
          <button class="barBtn" id="toolZoomOut" title="Zoom -" aria-label="Zoom -">
            <svg viewBox="0 0 24 24" fill="none">
              <path d="M11 19a8 8 0 1 1 0-16 8 8 0 0 1 0 16Z" stroke="currentColor" stroke-width="2"/>
              <path d="M8.5 11h5" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
              <path d="M20 20l-3.5-3.5" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            </svg>
          </button>
          <button class="barBtn" id="toolZoomIn" title="Zoom +" aria-label="Zoom +">
            <svg viewBox="0 0 24 24" fill="none">
              <path d="M11 19a8 8 0 1 1 0-16 8 8 0 0 1 0 16Z" stroke="currentColor" stroke-width="2"/>
              <path d="M8.5 11h5" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
              <path d="M11 8.5v5" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
              <path d="M20 20l-3.5-3.5" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            </svg>
          </button>
          <button class="barBtn" id="toolFit" title="Ajuster à l’écran" aria-label="Ajuster à l’écran">
            <svg viewBox="0 0 24 24" fill="none">
              <path d="M7 3H3v4M17 3h4v4M7 21H3v-4M17 21h4v-4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M9 9h6v6H9V9Z" stroke="currentColor" stroke-width="2"/>
            </svg>
          </button>
          <button class="barBtn" id="toolCompact" title="Nœuds compacts" aria-label="Nœuds compacts">
            <svg viewBox="0 0 24 24" fill="none">
              <path d="M8 7h8M8 12h5M8 17h8" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
              <path d="M18 10v4" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            </svg>
          </button>
          <button class="barBtn" id="toolLayoutH" title="Organiser horizontalement" aria-label="Organiser horizontalement">
            <svg viewBox="0 0 24 24" fill="none">
              <path d="M6 12h12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
              <path d="M6 12l3-3M6 12l3 3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M18 12l-3-3M18 12l-3 3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
          <button class="barBtn" id="toolLayoutV" title="Organiser verticalement" aria-label="Organiser verticalement">
            <svg viewBox="0 0 24 24" fill="none">
              <path d="M12 6v12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
              <path d="M12 6l-3 3M12 6l3 3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M12 18l-3-3M12 18l3-3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
          <button class="barBtn" id="toolWide" title="Canvas large (dock)" aria-label="Canvas large (dock)">
            <svg viewBox="0 0 24 24" fill="none">
              <path d="M4 7a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V7Z" stroke="currentColor" stroke-width="2"/>
              <path d="M9 12h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
              <path d="M9 12l2-2M9 12l2 2" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M15 12l-2-2M15 12l-2 2" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
          <button class="barBtn" id="toolPlay" title="Simuler" aria-label="Simuler">
            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l12-7-12-7Z"/></svg>
          </button>
          <button class="barBtn" id="toolUndo" title="Annuler" aria-label="Annuler">
            <svg viewBox="0 0 24 24" fill="none"><path d="M9 7H5v4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M5 11c2-4 8-6 12-2 4 4 2 10-3 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
          </button>
          <button class="barBtn" id="toolRedo" title="Rétablir" aria-label="Rétablir">
            <svg viewBox="0 0 24 24" fill="none"><path d="M15 7h4v4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M19 11c-2-4-8-6-12-2-4 4-2 10 3 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
          </button>
        </div>
      </div>
    </section>

    <!-- Right column -->
    <aside class="rightCol" aria-label="Library">
      <section class="panel libraryPanel">
        <div class="panelHeader">
          <div class="left"><span class="panelLabel">Library</span></div>
          <div class="right">
            <button class="miniIcon" id="libAI" title="Assistant IA"><svg viewBox="0 0 24 24" fill="none"><path d="M12 3l1.2 3.6L17 8l-3.8 1.4L12 13l-1.2-3.6L7 8l3.8-1.4L12 3Z" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/><path d="M19 13l.9 2.7L23 17l-3.1 1.3L19 21l-.9-2.7L15 17l3.1-1.3L19 13Z" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/></svg></button>
            <button class="miniIcon" data-collapse="library" title="Réduire / agrandir" aria-label="Réduire / agrandir"><svg viewBox="0 0 24 24" fill="none"><path d="M6 12h12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg></button>
          </div>
        </div>
        <div class="libraryBody" id="libraryList"></div>
        <div class="panelFooter">
          <div style="font-size:12px;color:var(--muted);font-weight:900;line-height:1.4;">
            Glisser une phase vers le canvas. Double-clic sur une phase pour éditer (modes, paramètres, décisions, durée…).
          </div>
        </div>
      </section>
    </aside>
  </main>

  <!-- AI Drawer -->
  <aside class="drawer" id="aiDrawer" aria-label="Assistant IA">
    <div class="drawerHead">
      <div class="drawerTitle"><span class="spark">IA</span> Assistant recette</div>
      <button class="miniIcon" id="closeAI" title="Fermer"><svg viewBox="0 0 24 24" fill="none"><path d="M6 6l12 12M18 6 6 18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg></button>
    </div>
    <div class="drawerBody">
      <div class="aiModeBar" role="tablist" aria-label="Assistant IA — navigation">
        <button class="aiModeBtn active" data-ai-mode="chat" role="tab" aria-selected="true">Chat</button>
        <button class="aiModeBtn" data-ai-mode="actions" role="tab" aria-selected="false">Actions</button>
        <button class="aiModeBtn" data-ai-mode="demos" role="tab" aria-selected="false">Démos</button>
        <button class="aiModeBtn" data-ai-mode="tools" role="tab" aria-selected="false">Outils</button>
      </div>

      <div class="aiView active" data-ai-view="chat" role="tabpanel">
        <div class="aiHint" id="aiStatus"></div>
        <div class="aiOut" id="aiOut">Assistant prêt. Je peux résumer le PDF, générer une recette, compléter des phases, reformuler des instructions et appliquer l’exemple “Preparation/Inoculation/Batch”.</div>
        <div class="aiPlanWrap" id="aiPlanWrap" style="display:none;">
          <div class="aiPlanHead">
            <div class="aiHint" style="margin:0;">Plan d’actions</div>
            <button class="miniIcon" id="aiRunPlan" title="Appliquer le plan" aria-label="Appliquer le plan">
              <svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l12-7-12-7Z"/></svg>
            </button>
            <button class="miniIcon" id="aiClearPlan" title="Vider le plan" aria-label="Vider le plan">
              <svg viewBox="0 0 24 24" fill="none"><path d="M6 7h12M10 7V5h4v2m-7 0 1 14h8l1-14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
            </button>
          </div>
          <div class="aiPlan" id="aiPlan"></div>
        </div>
        <div class="aiAsk">
          <input id="aiQ" placeholder="Pose une question : ex. 'semi-automatic', 'pO2 < 35%', 'Wait phase'…" />
          <button id="aiAskBtn">Envoyer</button>
        </div>
        <div class="aiHint">Astuce : clique sur une étape du plan pour appliquer depuis ce point. Raccourci : Ctrl+K.</div>
      </div>

      <div class="aiView" data-ai-view="actions" role="tabpanel">
        <div class="aiGrid">
          <button class="aiAction" data-ai="pdfSummary">Synthèse PDF</button>
          <button class="aiAction" data-ai="applyPdfExample">Appliquer exemple PDF</button>
          <button class="aiAction" data-ai="generateRecipe">Générer recette</button>
          <button class="aiAction" data-ai="completeSteps">Compléter étapes</button>
          <button class="aiAction" data-ai="rewrite">Reformuler</button>
          <button class="aiAction" data-ai="conditions">Conditions pO2</button>
        </div>
        <div class="aiHint">Le résultat apparaît dans l’onglet Chat.</div>
      </div>

      <div class="aiView" data-ai-view="demos" role="tabpanel">
        <div class="aiRow">
          <div class="aiHint" style="margin:0;">Vitesse démo</div>
          <select id="aiSpeed" aria-label="Vitesse démo">
            <option value="2.4">Très lent</option>
            <option value="1.8">Lent</option>
            <option value="1.35">Normal</option>
            <option value="1.0">Rapide</option>
          </select>
        </div>
        <div style="height:10px;"></div>
        <div class="aiGrid oneCol" id="aiDemos">
          <button class="aiAction" data-demo="demo_full">Démo — Recette PDF complète (pas à pas)</button>
          <button class="aiAction" data-demo="demo_prep">Démo — Preparation (TEMP/pH + Wait)</button>
          <button class="aiAction" data-demo="demo_batch">Démo — Batch (boucle pO2 + conditions)</button>
          <button class="aiAction" data-demo="demo_operator">Démo — Operator prompt (décisions + transitions)</button>
          <button class="aiAction" data-demo="demo_jump">Démo — Jump link (boucle + sortie)</button>
          <button class="aiAction" data-demo="demo_vertical">Démo — Layout vertical (ports haut/bas)</button>
          <button class="aiAction" data-demo="demo_fix">Démo — IA complète l’opération courante</button>
          <button class="aiAction" data-demo="demo_feed">Démo — Batch + Feed (Profile + Pump)</button>
          <button class="aiAction" data-demo="demo_tune">Démo — IA ajuste setpoints (pH/TEMP/pO2)</button>
          <button class="aiAction" data-demo="demo_reset_calc">Démo — Reset calculation (getValue + calcCycle)</button>
        </div>
      </div>

      <div class="aiView" data-ai-view="tools" role="tabpanel">
        <div class="aiHint">Variables rapides (capteurs) :</div>
        <div class="varChips" id="aiVars"></div>
        <label class="aiHint" style="display:flex;align-items:center;gap:8px;margin-top:10px;">
          <input type="checkbox" id="aiAutoApply" />
          Auto-appliquer les actions
        </label>
        <button class="btn ghost" id="openPdfBtn" style="width:100%;justify-content:center;margin-top:10px;">Ouvrir le PDF</button>
        <div class="aiHint" style="margin-top:10px;">
          Démo locale (sans Internet) : réponses basées sur le PDF et des règles.
        </div>
      </div>
    </div>
    <div class="aiFooter">
      <button class="btn ghost" id="copyAI">Copier</button>
      <button class="btn dark" id="applyAI">Appliquer</button>
    </div>
  </aside>

  <!-- Select variable modal -->
  <div class="modalBackdrop" id="varBackdrop" role="dialog" aria-modal="true" aria-label="SELECT VARIABLE">
    <div class="modal varModal">
      <div class="modalHead">
        <div class="title" id="varTitle">SELECT VARIABLE</div>
        <button class="miniIcon" id="closeVar" title="Fermer" aria-label="Fermer">
          <svg viewBox="0 0 24 24" fill="none"><path d="M6 6l12 12M18 6 6 18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
        </button>
      </div>
      <div class="varWrap">
        <div class="aiHint" id="varHint">Choisis une variable pour l’insérer dans le champ actif.</div>
        <div class="varToolbar">
          <input id="varSearch" type="search" placeholder="Filtrer… (ex: pO2, Setpoint, Mode)" />
          <button class="btn ghost" id="varReset" style="height:38px;">Reset</button>
        </div>
        <div class="varList" id="varList" role="listbox" tabindex="0" aria-label="Liste variables"></div>
      </div>
      <div class="modalFoot">
        <button class="btn ghost" id="varCancel">CLOSE</button>
        <button class="btn dark" id="varOk">OK</button>
      </div>
    </div>
  </div>

  <!-- Select phase modal (Instrument phase) -->
  <div class="modalBackdrop" id="phaseBackdrop" role="dialog" aria-modal="true" aria-label="SELECT PHASE">
    <div class="modal varModal">
      <div class="modalHead">
        <div class="title" id="phaseTitle">SELECT PHASE</div>
        <button class="miniIcon" id="closePhase" title="Fermer" aria-label="Fermer">
          <svg viewBox="0 0 24 24" fill="none"><path d="M6 6l12 12M18 6 6 18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
        </button>
      </div>
      <div class="varWrap">
        <div class="aiHint" id="phaseHint">Choisis une phase/module (unit) pour l’Instrument phase.</div>
        <div class="varToolbar">
          <input id="phaseSearch" type="search" placeholder="Filtrer… (ex: pO2, TEMP, Pump)" />
          <button class="btn ghost" id="phaseReset" style="height:38px;">Reset</button>
        </div>
        <div class="varList" id="phaseList" role="listbox" tabindex="0" aria-label="Liste phases"></div>
      </div>
      <div class="modalFoot">
        <button class="btn ghost" id="phaseCancel">CLOSE</button>
        <button class="btn dark" id="phaseOk">OK</button>
      </div>
    </div>
  </div>

  <!-- Select calculation modal (Formula / Calculation) -->
  <div class="modalBackdrop" id="calcBackdrop" role="dialog" aria-modal="true" aria-label="SELECT CALCULATION">
    <div class="modal varModal" style="width:min(920px,100%);">
      <div class="modalHead">
        <div class="title" id="calcTitle">SELECT CALCULATION</div>
        <button class="miniIcon" id="closeCalc" title="Fermer" aria-label="Fermer">
          <svg viewBox="0 0 24 24" fill="none"><path d="M6 6l12 12M18 6 6 18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
        </button>
      </div>
      <div class="varWrap">
        <div class="aiHint" id="calcHint">Choisis un calcul (name/description) à insérer.</div>
        <div class="varToolbar">
          <input id="calcSearch" type="search" placeholder="Filtrer… (ex: OUR, CER, TEMP)" />
          <button class="btn ghost" id="calcReset" style="height:38px;">Reset</button>
        </div>
        <div class="varList" id="calcList" role="listbox" tabindex="0" aria-label="Liste calculs"></div>
      </div>
      <div class="modalFoot">
        <button class="btn ghost" id="calcCancel">CLOSE</button>
        <button class="btn dark" id="calcOk">OK</button>
      </div>
    </div>
  </div>

  <!-- Formula editor modal -->
  <div class="modalBackdrop" id="formulaBackdrop" role="dialog" aria-modal="true" aria-label="Éditeur de formule">
    <div class="modal fxModal">
      <div class="modalHead">
        <div class="title" id="fxTitle">Éditeur de formule</div>
        <button class="miniIcon" id="closeFx" title="Fermer">
          <svg viewBox="0 0 24 24" fill="none"><path d="M6 6l12 12M18 6 6 18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
        </button>
      </div>
      <div class="fxWrap">
        <div class="fxTop">
          <div class="fxMeta">
            <div class="fxMetaTitle">
              <span id="fxModeLabel">EDIT CONDITION</span>
              <small>MFCS-like</small>
            </div>
            <div class="fxMetaHint" id="fxHint">Insère des variables, fonctions et opérateurs. La prévisualisation utilise les valeurs capteur de la démo.</div>
            <div class="fxMetaHint" id="fxLegend"></div>
          </div>
          <div class="fxInput">
            <div class="fxLabelRow">
              <label id="fxFieldLabel">CONDITION</label>
              <button class="miniIcon" id="fxValidate" title="Valider la syntaxe" aria-label="Valider la syntaxe">
                <svg viewBox="0 0 24 24" fill="none"><path d="M20 6 9 17l-5-5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
              </button>
            </div>
            <textarea class="fxText" id="fxText" spellcheck="false"></textarea>
            <div class="fxPreview" id="fxPreview">Prévisualisation : —</div>
          </div>
        </div>

        <div class="fxPad">
          <div class="fxGroup">
            <div class="fxGroupTitle">VARIABLE</div>
            <input class="fxSearch" id="fxVarSearch" type="search" placeholder="Filtrer… (ex: pO2, O2_)" />
            <div class="fxBtns" id="fxVars"></div>
          </div>
          <div class="fxGroup">
            <div class="fxGroupTitle">FORMULA</div>
            <div class="fxBtns" id="fxFuncs"></div>
          </div>
          <div class="fxGroup">
            <div class="fxGroupTitle">OTHERS</div>
            <div class="fxBtns" id="fxOps"></div>
          </div>
          <div class="fxGroup">
            <div class="fxGroupTitle">NUM BLOCK</div>
            <div class="fxNumGrid" id="fxNums"></div>
          </div>
        </div>
      </div>
      <div class="modalFoot">
        <button class="btn ghost" id="fxCancel">Fermer</button>
        <button class="btn dark" id="fxSave">SAVE</button>
      </div>
    </div>
  </div>

  <!-- Phase editor modal -->
  <div class="modalBackdrop" id="modalBackdrop" role="dialog" aria-modal="true" aria-label="Éditeur de phase">
    <div class="modal">
      <div class="modalHead">
        <div class="title" id="modalTitle">Éditer une phase</div>
        <button class="miniIcon" id="closeModal" title="Fermer"><svg viewBox="0 0 24 24" fill="none"><path d="M6 6l12 12M18 6 6 18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg></button>
      </div>
      <div class="modalBody">
        <div class="stack">
          <div class="field">
            <label>Nom *</label>
            <input id="fName" />
          </div>
          <div class="field">
            <label>Mode</label>
            <select id="fMode">
              <option value="Automatic">Automatic</option>
              <option value="Semi-Automatic">Semi-Automatic</option>
              <option value="Operator-only">Operator-only</option>
            </select>
          </div>
          <div class="field">
            <label>Description</label>
            <textarea id="fDesc"></textarea>
          </div>
        </div>

        <div class="stack" id="typeFields"></div>
      </div>
      <div class="modalFoot">
        <button class="btn ghost" id="deleteNodeBtn">Supprimer</button>
        <button class="btn dark" id="saveNodeBtn">Sauvegarder</button>
      </div>
    </div>
  </div>

  <!-- Version History modal -->
  <div class="modalBackdrop" id="historyBackdrop" role="dialog" aria-modal="true" aria-label="Historique">
    <div class="modal" style="width:min(700px,95%);max-height:85vh;">
      <div class="modalHead">
        <div class="title" id="historyTitle">Historique des versions</div>
        <button class="miniIcon" id="closeHistory" title="Fermer">
          <svg viewBox="0 0 24 24" fill="none"><path d="M6 6l12 12M18 6 6 18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
        </button>
      </div>
      <div class="modalBody" style="padding:0;max-height:65vh;overflow-y:auto;">
        <!-- Branch selector -->
        <div style="padding:14px 18px;border-bottom:1px solid var(--stroke);display:flex;align-items:center;gap:10px;flex-wrap:wrap;">
          <span style="font-weight:700;font-size:13px;">Branche :</span>
          <select id="histBranchSelect" style="padding:4px 10px;border-radius:8px;border:1px solid var(--stroke);font-weight:600;font-size:13px;"></select>
          <span style="font-size:11px;color:var(--muted);padding:2px 8px;background:#f1f5f9;border-radius:6px;" id="histBranchInfo"></span>
          <button class="btn ghost" id="histNewBranch" style="font-size:12px;margin-left:auto;">+ Variante</button>
        </div>
        <!-- Version list -->
        <div id="histVersionList" style="padding:8px 0;"></div>
      </div>
      <div class="modalFoot">
        <button class="btn ghost" id="histClose">Fermer</button>
        <button class="btn dark" id="histCompare">Comparer les 2 versions cochees</button>
      </div>
    </div>
  </div>

  <script>
    (() => {
      // WORKFLOW_UI_SCRIPT_START
      "use strict";

      const PDF_KB = {
        phaseTypes: {
          start: "Start : point de départ de l’opération.",
          parameter:
            "Parameter phase : contrôle la phase selon des paramètres (setpoints) pour les variables du module. Mode : Automatic ou Semi-Automatic (confirmation utilisateur).",
          wait: "Wait phase : définit un temps d’attente avant la phase suivante (unité s/min/h/j).",
          operator:
            "Operator prompt phase : dépend d’une décision utilisateur (max. 3 décisions), avec notification.",
          profile:
            "Profile phase : applique un profil de setpoint (points, interpolation, unité de temps).",
          instrument:
            "Instrument phase : exécute une séquence sur un device (paramètres par défaut), option Force restart.",
          calc:
            "Calculation phase (démo) : calcule une valeur à partir d’une formule et de variables capteur (ex: pO2.Value, pH.Value…).",
          end: "End : fin d’opération (une seule End par opération).",
        },
        exampleRecipe: null, // rempli plus bas
      };

      const iconByType = {
        start: { bg: "var(--green)", label: "▶" },
        parameter: { bg: "var(--blue)", label: "P" },
        operator: { bg: "var(--amber)", label: "✎" },
        instrument: { bg: "var(--purple)", label: "⚙" },
        wait: { bg: "var(--muted-2)", label: "⏱" },
        profile: { bg: "#10b981", label: "↺" },
        calc: { bg: "#06b6d4", label: "ƒx" },
        end: { bg: "var(--red)", label: "■" },
      };

      const libraryItems = [
        { type: "start", label: "Start", hint: "Début" },
        { type: "parameter", label: "Parameter phase", hint: "Setpoints" },
        { type: "operator", label: "Operator prompt phase", hint: "Décisions" },
        { type: "instrument", label: "Instrument phase", hint: "Device" },
        { type: "wait", label: "Wait phase", hint: "Timer" },
        { type: "profile", label: "Profile phase", hint: "Profil" },
        { type: "calc", label: "Calculation phase", hint: "Formule" },
        { type: "end", label: "End", hint: "Fin" },
      ];

      const recipeCatalog = [
        { id: "grow-a", name: "Grow-A" },
        { id: "grow-b", name: "Grow-B" },
        { id: "feed-1", name: "Feed-1" },
        { id: "mix-1", name: "Mix-1" },
        { id: "o2-opt", name: "O\u2082-Opt" },
        { id: "base-1", name: "Base-1" },
      ];

      PDF_KB.exampleRecipe = {
        name: "Example batch process (PDF)",
        operations: [
          {
            id: "prep",
            name: "Preparation",
            nodes: [
              { id: "prep_start", type: "start", title: "Start", sub: "", x: 220, y: 200, data: { mode: "Automatic" } },
              {
                id: "prep_param",
                type: "parameter",
                title: "Set temperature and pH",
                sub: "TEMP 37°C · pH 6.8",
                x: 440,
                y: 190,
                data: {
                  mode: "Automatic",
                  parameters: [
                    "TEMP.State=remote",
                    "TEMP.Mode=auto",
                    "TEMP.Setpoint=37",
                    "pH.State=remote",
                    "pH.Mode=auto",
                    "pH.Setpoint=6.8",
                  ],
                },
              },
              { id: "prep_wait", type: "wait", title: "Wait 30 min", sub: "Durée 30 min", x: 700, y: 190, data: { mode: "Automatic", duration: 30, unit: "min" } },
              { id: "prep_end", type: "end", title: "End", sub: "", x: 940, y: 200, data: { mode: "Automatic" } },
            ],
            edges: [
              { id: "e1", from: "prep_start", to: "prep_param" },
              { id: "e2", from: "prep_param", to: "prep_wait" },
              { id: "e3", from: "prep_wait", to: "prep_end" },
            ],
          },
          {
            id: "inoc",
            name: "Inoculation",
            nodes: [
              { id: "inoc_start", type: "start", title: "Start", sub: "", x: 220, y: 200, data: { mode: "Automatic" } },
              { id: "inoc_op", type: "parameter", title: "Inoculate", sub: "Semi-Automatic", x: 440, y: 190, data: { mode: "Semi-Automatic", parameters: [] } },
              { id: "inoc_end", type: "end", title: "End", sub: "", x: 700, y: 200, data: { mode: "Automatic" } },
            ],
            edges: [
              { id: "e1", from: "inoc_start", to: "inoc_op" },
              { id: "e2", from: "inoc_op", to: "inoc_end" },
            ],
          },
          {
            id: "batch",
            name: "Batch",
            nodes: [
              { id: "batch_start", type: "start", title: "Start", sub: "", x: 220, y: 200, data: { mode: "Automatic" } },
              { id: "batch_wait", type: "wait", title: "Wait 1 min", sub: "Durée 1 min", x: 440, y: 190, data: { mode: "Automatic", duration: 1, unit: "min" } },
              {
                id: "batch_param",
                type: "parameter",
                title: "Activate pO2 control",
                sub: "pO2 Setpoint 35%",
                x: 700,
                y: 190,
                data: { mode: "Automatic", parameters: ["pO2.State=remote", "pO2.Mode=auto", "pO2.Setpoint=35"] },
              },
              { id: "batch_end", type: "end", title: "End", sub: "", x: 970, y: 200, data: { mode: "Automatic" } },
            ],
            edges: [
              { id: "e1", from: "batch_start", to: "batch_wait", condition: "pO2.Value < 35%" },
              { id: "e2", from: "batch_wait", to: "batch_param", condition: "pO2.Value < 35% (A)" },
              { id: "e3", from: "batch_wait", to: "batch_wait", condition: "pO2.Value > 35% (B)" },
              { id: "e4", from: "batch_param", to: "batch_end" },
            ],
          },
        ],
      };

      const state = {
        recipeId: "grow-a",
        recipeChecks: new Set(),
        recipesStore: {},
        operations: [
          { id: "prep", name: "Preparation", nodes: [], edges: [] },
          { id: "inoc", name: "Inoculation", nodes: [], edges: [] },
          { id: "batch", name: "Batch", nodes: [], edges: [] },
        ],
        currentOpId: "prep",
        selection: { nodeId: null, nodeIds: new Set() },
        uiFocusArea: "canvas", // canvas | recipe | op
        connectMode: { fromNodeId: null, pointer: null, cancelToken: 0 },
        snapLink: { draggingId: null, inFromId: null, outToId: null, armedAt: 0, armTimer: 0 },
        history: [],
        future: [],
        ai: { lastText: "", lastActions: null, running: false },
      };

      const dom = {
        canvas: document.getElementById("canvas"),
        wires: document.getElementById("wires"),
        nodesLayer: document.getElementById("nodesLayer"),
        marquee: document.getElementById("marquee"),
        snapHint: document.getElementById("snapHint"),
        nodeEls: new Map(),
      };

      const PREFS_KEY = "workflow_ui_prefs_v3";
      const uiPrefs = {
        collapseRecipe: false,
        collapseOp: false,
        collapseLibrary: false,
        compactNodes: false,
        wideCanvas: false,
        handMode: true,
        wireMode: "auto", // auto | h | v
        lastLayout: "h", // h | v
        aiSpeed: 1.8, // >1 = slower demos
        aiMode: "chat", // chat | actions | demos | tools
        view: { x: 0, y: 0, zoom: 1 },
      };

      const SNAP_ARM_MS = 2000;
      const keyState = { space: false };
      const canvasGesture = { panning: null, boxing: null };

      function byId(id) {
        return document.getElementById(id);
      }
      function uid(prefix = "id") {
        return `${prefix}_${Math.random().toString(16).slice(2, 10)}`;
      }
      function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }
      function escapeHtml(str) {
        return String(str ?? "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }
      function cssEscape(value) {
        const s = String(value ?? "");
        if (window.CSS && typeof window.CSS.escape === "function") return window.CSS.escape(s);
        return s.replace(/["\\]/g, "\\$&");
      }
      function deepClone(value) {
        if (window.structuredClone) return structuredClone(value);
        return JSON.parse(JSON.stringify(value));
      }
      function isBackdropOpen(id) {
        const el = byId(id);
        return !!el && el.classList.contains("active");
      }
      function anyModalOpen() {
        return (
          isBackdropOpen("modalBackdrop") ||
          isBackdropOpen("varBackdrop") ||
          isBackdropOpen("formulaBackdrop") ||
          isBackdropOpen("phaseBackdrop") ||
          isBackdropOpen("calcBackdrop") ||
          isBackdropOpen("historyBackdrop")
        );
      }
      function updateModalLock() {
        document.body.classList.toggle("modalOpen", anyModalOpen());
      }

      function ensureSelectionSet() {
        const sel = state.selection || (state.selection = { nodeId: null, nodeIds: new Set() });
        if (sel.nodeIds instanceof Set) return sel.nodeIds;
        sel.nodeIds = new Set(Array.isArray(sel.nodeIds) ? sel.nodeIds : []);
        return sel.nodeIds;
      }

      function clearSelection() {
        ensureSelectionSet().clear();
        state.selection.nodeId = null;
      }

      function setSelectionSingle(nodeId) {
        const ids = ensureSelectionSet();
        ids.clear();
        if (nodeId) ids.add(nodeId);
        state.selection.nodeId = nodeId || null;
      }

      function toggleSelection(nodeId) {
        if (!nodeId) return;
        const ids = ensureSelectionSet();
        if (ids.has(nodeId)) {
          ids.delete(nodeId);
          if (state.selection.nodeId === nodeId) state.selection.nodeId = ids.values().next().value || null;
          return;
        }
        ids.add(nodeId);
        state.selection.nodeId = nodeId;
      }

      function isSelected(nodeId) {
        return ensureSelectionSet().has(nodeId);
      }

      function loadPrefs() {
        try {
          const raw = localStorage.getItem(PREFS_KEY);
          if (!raw) return;
          const parsed = JSON.parse(raw);
          Object.assign(uiPrefs, parsed || {});
        } catch {
          // ignore
        }
      }

      function savePrefs() {
        try {
          localStorage.setItem(PREFS_KEY, JSON.stringify(uiPrefs));
        } catch {
          // ignore
        }
      }

      function effectiveWireDir() {
        const mode = String(uiPrefs.wireMode || "auto").toLowerCase();
        if (mode === "v" || mode === "vertical") return "v";
        if (mode === "h" || mode === "horizontal") return "h";
        return String(uiPrefs.lastLayout || "h").toLowerCase() === "v" ? "v" : "h";
      }

      function applyPrefsToDom() {
        document.body.classList.toggle("collapseRecipe", !!uiPrefs.collapseRecipe);
        document.body.classList.toggle("collapseOp", !!uiPrefs.collapseOp);
        document.body.classList.toggle("collapseLibrary", !!uiPrefs.collapseLibrary);
        document.body.classList.toggle("compactNodes", !!uiPrefs.compactNodes);
        document.body.classList.toggle("wideCanvas", !!uiPrefs.wideCanvas);
        document.body.classList.toggle("handMode", !!uiPrefs.handMode);
        document.body.classList.toggle("wireVertical", effectiveWireDir() === "v");
        applyAiSpeedCss();
        applyViewTransform();
        updateCollapseButtons();
        applyWideCanvasDock();
      }

      // ===== Canvas wide dock =====
      const dock = {
        open: null, // recipe | op | library | null
        dom: null,
        panels: null,
        homes: new Map(),
      };

      function ensureDockDom() {
        if (dock.dom) return dock.dom;
        const row = byId("dockRow");
        const recipeWrap = byId("dockRecipeWrap");
        const opWrap = byId("dockOpWrap");
        const libWrap = byId("dockLibraryWrap");
        const btns = row ? Array.from(row.querySelectorAll(".dockBtn[data-dock]")) : [];
        const byKey = {};
        btns.forEach((b) => {
          byKey[b.dataset.dock] = b;
        });
        dock.dom = { row, recipeWrap, opWrap, libWrap, btns, byKey };
        return dock.dom;
      }

      function rememberDockHome(el) {
        if (!el) return;
        if (dock.homes.has(el)) return;
        dock.homes.set(el, { parent: el.parentElement, next: el.nextSibling });
      }

      function restoreDockHome(el) {
        if (!el) return;
        const home = dock.homes.get(el);
        if (!home?.parent) return;
        try {
          if (home.next && home.next.parentNode === home.parent) home.parent.insertBefore(el, home.next);
          else home.parent.appendChild(el);
        } catch {
          try {
            home.parent.appendChild(el);
          } catch {
            // ignore
          }
        }
      }

      function ensureDockPanels() {
        if (dock.panels) return dock.panels;
        const recipe = document.querySelector(".recipePanel");
        const op = document.querySelector(".opPanel");
        const library = document.querySelector(".libraryPanel");
        dock.panels = { recipe, op, library };
        [recipe, op, library].forEach(rememberDockHome);
        return dock.panels;
      }

      function renderDock() {
        const d = ensureDockDom();
        if (!d.row) return;

        const open = uiPrefs.wideCanvas ? dock.open : null;
        const wraps = { recipe: d.recipeWrap, op: d.opWrap, library: d.libWrap };

        Object.entries(wraps).forEach(([key, wrap]) => {
          if (!wrap) return;
          const isOpen = open === key;
          wrap.classList.toggle("open", isOpen);
          wrap.setAttribute("aria-hidden", isOpen ? "false" : "true");
        });

        Object.entries(d.byKey).forEach(([key, btn]) => {
          const pressed = open === key;
          btn.classList.toggle("active", pressed);
          btn.setAttribute("aria-pressed", pressed ? "true" : "false");
        });
      }

      function setDockOpen(key) {
        if (!uiPrefs.wideCanvas) return;
        dock.open = dock.open === key ? null : key;
        renderDock();
      }

      function closeDock() {
        dock.open = null;
        renderDock();
      }

      function applyWideCanvasDock() {
        const d = ensureDockDom();
        if (!d.row) return;
        const p = ensureDockPanels();

        if (uiPrefs.wideCanvas) {
          if (p.recipe && d.recipeWrap && p.recipe.parentElement !== d.recipeWrap) d.recipeWrap.appendChild(p.recipe);
          if (p.op && d.opWrap && p.op.parentElement !== d.opWrap) d.opWrap.appendChild(p.op);
          if (p.library && d.libWrap && p.library.parentElement !== d.libWrap) d.libWrap.appendChild(p.library);
        } else {
          closeDock();
          restoreDockHome(p.recipe);
          restoreDockHome(p.op);
          restoreDockHome(p.library);
        }

        renderDock();
      }

      function getView() {
        const v = uiPrefs.view && typeof uiPrefs.view === "object" ? uiPrefs.view : null;
        const x = Number(v?.x);
        const y = Number(v?.y);
        const zoom = Number(v?.zoom);
        const next = {
          x: Number.isFinite(x) ? x : 0,
          y: Number.isFinite(y) ? y : 0,
          zoom: clamp(Number.isFinite(zoom) ? zoom : 1, 0.25, 2.5),
        };
        uiPrefs.view = next;
        return next;
      }

      function applyViewTransform() {
        const layer = dom.nodesLayer || byId("nodesLayer");
        if (!layer) return;
        dom.nodesLayer = layer;
        const v = getView();
        layer.style.transform = `translate(${v.x}px, ${v.y}px) scale(${v.zoom})`;
      }

      function canvasPointFromEvent(e) {
        const r = dom.canvas.getBoundingClientRect();
        return { x: e.clientX - r.left, y: e.clientY - r.top };
      }

      function screenToWorld(pt) {
        const v = getView();
        return { x: (pt.x - v.x) / v.zoom, y: (pt.y - v.y) / v.zoom };
      }

      function worldToScreen(pt) {
        const v = getView();
        return { x: pt.x * v.zoom + v.x, y: pt.y * v.zoom + v.y };
      }

      function setView(next, { save } = {}) {
        const current = getView();
        const x = Number(next?.x);
        const y = Number(next?.y);
        const zoom = Number(next?.zoom);
        uiPrefs.view = {
          x: Number.isFinite(x) ? x : current.x,
          y: Number.isFinite(y) ? y : current.y,
          zoom: clamp(Number.isFinite(zoom) ? zoom : current.zoom, 0.25, 2.5),
        };
        if (save !== false) savePrefs();
        applyViewTransform();
        updateWires?.();
      }

      function zoomAt(screenPt, nextZoom, { save } = {}) {
        const v = getView();
        const z = clamp(Number(nextZoom), 0.25, 2.5);
        const p = screenPt || { x: 0, y: 0 };
        const world = screenToWorld(p);
        const nx = p.x - world.x * z;
        const ny = p.y - world.y * z;
        setView({ x: nx, y: ny, zoom: z }, { save });
      }

      function fitViewToOp(opId, { save } = {}) {
        const op = opId ? getOp(opId) : getCurrentOp();
        if (!op || !op.nodes?.length) return;

        const rect = dom.canvas.getBoundingClientRect();
        const pad = 60;
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;

        op.nodes.forEach((n) => {
          const el = dom.nodeEls.get(n.id);
          const w = el?.offsetWidth || 240;
          const h = el?.offsetHeight || 56;
          minX = Math.min(minX, n.x);
          minY = Math.min(minY, n.y);
          maxX = Math.max(maxX, n.x + w);
          maxY = Math.max(maxY, n.y + h);
        });
        if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) return;

        const worldMinX = minX - pad;
        const worldMinY = minY - pad;
        const worldW = Math.max(1, maxX - minX + pad * 2);
        const worldH = Math.max(1, maxY - minY + pad * 2);

        const zoom = clamp(Math.min(rect.width / worldW, rect.height / worldH), 0.25, 1.6);
        const x = -worldMinX * zoom + (rect.width - worldW * zoom) / 2;
        const y = -worldMinY * zoom + (rect.height - worldH * zoom) / 2;
        setView({ x, y, zoom }, { save });
      }

      function aiSpeedFactor() {
        const raw = Number(uiPrefs.aiSpeed);
        if (!Number.isFinite(raw)) return 1.35;
        return clamp(raw, 0.75, 3);
      }

      function aiMs(ms) {
        const v = Number(ms);
        const base = Number.isFinite(v) ? v : 0;
        return Math.round(base * aiSpeedFactor());
      }

      function applyAiSpeedCss() {
        const factor = aiSpeedFactor();
        const cursor = clamp(Math.round(220 * factor), 140, 680);
        document.documentElement.style.setProperty("--ai-cursor-ms", `${cursor}ms`);
      }

      const sensors = {
        TEMP: { label: "TEMP", unit: "°C", value: 37, min: 20, max: 45, step: 0.08 },
        pH: { label: "pH", unit: "", value: 6.8, min: 5.5, max: 8.5, step: 0.03 },
        pO2: { label: "pO2", unit: "%", value: 35, min: 0, max: 100, step: 0.9 },
        OD: { label: "OD", unit: "", value: 12.3, min: 0, max: 30, step: 0.2 },
        STIRR: { label: "STIRR", unit: "rpm", value: 350, min: 0, max: 1200, step: 12 },
        O2_Flow: { label: "O2_Flow", unit: "ml/min", value: 120, min: 0, max: 1000, step: 6 },
        O2_Totalizer: { label: "O2_Totalizer", unit: "ml", value: 2350, min: 0, max: 200000, step: 18 },
      };

      const variableCatalog = [
        { token: "TEMP.Value", label: "TEMP.Value", sensor: "TEMP" },
        { token: "pH.Value", label: "pH.Value", sensor: "pH" },
        { token: "pO2.Value", label: "pO2.Value", sensor: "pO2" },
        { token: "OD.Value", label: "OD.Value", sensor: "OD" },
        { token: "STIRR_1.Value", label: "STIRR_1.Value", sensor: "STIRR" },
        { token: "O2_Flow.Value", label: "O2_Flow.Value", sensor: "O2_Flow" },
        { token: "O2_Totalizer.Value", label: "O2_Totalizer.Value", sensor: "O2_Totalizer" },

        // Common control variables (PDF-like)
        { token: "TEMP.State", label: "TEMP.State" },
        { token: "TEMP.Mode", label: "TEMP.Mode" },
        { token: "TEMP.Setpoint", label: "TEMP.Setpoint" },
        { token: "pH.State", label: "pH.State" },
        { token: "pH.Mode", label: "pH.Mode" },
        { token: "pH.Setpoint", label: "pH.Setpoint" },
        { token: "pO2.State", label: "pO2.State" },
        { token: "pO2.Mode", label: "pO2.Mode" },
        { token: "pO2.Setpoint", label: "pO2.Setpoint" },
      ];

      // Instrument “SELECT PHASE” (demo catalogue, inspired by MFCS manual)
      const phaseCatalog = [
        { name: "TEMP", unit: "L1-1", desc: "Temperature control module" },
        { name: "pH", unit: "L1-1", desc: "pH control module" },
        { name: "pO2", unit: "L1-1", desc: "Dissolved oxygen control module" },
        { name: "STIRR_1", unit: "L1-1", desc: "Agitation / stirrer" },
        { name: "FEED_PUMP", unit: "L1-1", desc: "Feed pump sequence" },
        { name: "BASE_PUMP", unit: "L1-1", desc: "Base pump sequence" },
        { name: "AIRFLOW", unit: "L1-1", desc: "Air flow / gas mixing" },
      ];

      // “SELECT CALCULATION” (demo catalogue, inspired by MFCS manual screenshots)
      const calcCatalog = [
        { name: "Calc_BASET_1_1", short: "Convert ml → g BASET", desc: "Example: Convert \"ml\" to \"g\" for BASET" },
        { name: "Calc_TEMP_C", short: "Temp C → F", desc: "Convert °C to °F" },
        { name: "CER_value", short: "Carbon Dioxide Evolution Rate", desc: "CER (CO₂ evolution rate)" },
        { name: "OUR_value", short: "Oxygen Uptake Rate", desc: "OUR (O₂ uptake rate)" },
        { name: "RQ_value", short: "Respiratory Quotient", desc: "RQ (CO₂ / O₂ ratio)" },
      ];

      let lastTextTarget = null;

      function formatValue(n) {
        if (!Number.isFinite(n)) return "—";
        const abs = Math.abs(n);
        const digits = abs >= 100 ? 0 : abs >= 10 ? 1 : 2;
        return n.toFixed(digits);
      }

      async function copyToClipboard(text) {
        try {
          await navigator.clipboard.writeText(text);
        } catch {
          // ignore
        }
      }

      function insertAtCaret(el, text) {
        try {
          const start = el.selectionStart ?? el.value.length;
          const end = el.selectionEnd ?? el.value.length;
          const before = el.value.slice(0, start);
          const after = el.value.slice(end);
          el.value = before + text + after;
          const pos = start + text.length;
          el.setSelectionRange?.(pos, pos);
          el.dispatchEvent(new Event("input", { bubbles: true }));
        } catch {
          el.value = (el.value || "") + text;
          el.dispatchEvent(new Event("input", { bubbles: true }));
        }
      }

      function pickVariable(token) {
        const t = String(token || "").trim();
        if (!t) return;
        const active = document.activeElement;
        const target = lastTextTarget && lastTextTarget.isConnected ? lastTextTarget : null;
        const canInsert = target && (target.tagName === "INPUT" || target.tagName === "TEXTAREA");
        if (canInsert && active === target) {
          insertAtCaret(target, t);
          target.focus?.();
          return;
        }
        copyToClipboard(t);
      }

      function getSensorValueByToken(token) {
        const entry = variableCatalog.find((v) => v.token === token);
        if (!entry?.sensor) return null;
        const s = sensors[entry.sensor];
        return s ? Number(s.value) : null;
      }

      function safeEvalExpression(expr) {
        const normalized = String(expr || "").replaceAll(",", ".").trim();
        if (!normalized) return null;
        if (/[^0-9+\-*/().\s]/.test(normalized)) return null;
        try {
          const val = Function(`"use strict"; return (${normalized});`)();
          return Number.isFinite(val) ? val : null;
        } catch {
          return null;
        }
      }

      function evalFormulaWithSensors(formula) {
        const raw = String(formula || "").trim();
        if (!raw) return null;

        const CALC_CYCLE_SECONDS = 60;

        function stripAssignment(expr) {
          const s = String(expr || "");
          for (let i = 0; i < s.length; i++) {
            if (s[i] !== "=") continue;
            const prev = s[i - 1] || "";
            const next = s[i + 1] || "";
            if (prev === "<" || prev === ">" || prev === "!" || prev === "=") continue;
            if (next === "=") continue;
            return s.slice(i + 1);
          }
          return s;
        }

        const expr = stripAssignment(normalizeDotSpacing(raw).replaceAll("×", "*").replaceAll("%", "")).trim();
        if (!expr) return null;

        function evalNumericExpression(input) {
          const s = String(input || "");
          let i = 0;

          const isSpace = (ch) => ch === " " || ch === "\t" || ch === "\n" || ch === "\r";
          const isDigit = (ch) => ch >= "0" && ch <= "9";
          const isIdentStart = (ch) => (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z") || ch === "_";
          const isIdentChar = (ch) =>
            isIdentStart(ch) || isDigit(ch) || ch === "_" || ch === ".";

          function skip() {
            while (i < s.length && isSpace(s[i])) i++;
          }

          function parseNumber() {
            skip();
            const start = i;
            let sawDigit = false;
            if (s[i] === ".") i++;
            while (i < s.length && isDigit(s[i])) {
              i++;
              sawDigit = true;
            }
            if (s[i] === ".") {
              i++;
              while (i < s.length && isDigit(s[i])) {
                i++;
                sawDigit = true;
              }
            }
            if (!sawDigit) return null;
            const num = Number(s.slice(start, i));
            return Number.isFinite(num) ? num : null;
          }

          function parseIdentifier() {
            skip();
            const start = i;
            if (!isIdentStart(s[i] || "")) return null;
            i++;
            while (i < s.length && isIdentChar(s[i])) i++;
            return s.slice(start, i);
          }

          function parsePrimary() {
            skip();
            const ch = s[i] || "";

            if (ch === "+" || ch === "-") {
              i++;
              const v = parsePrimary();
              if (v == null) return null;
              return ch === "-" ? -v : v;
            }

            if (ch === "(") {
              i++;
              const v = parseAddSub();
              skip();
              if (s[i] !== ")") return null;
              i++;
              return v;
            }

            if (isDigit(ch) || ch === ".") return parseNumber();

            if (isIdentStart(ch)) {
              const name = parseIdentifier();
              if (!name) return null;
              const lname = name.toLowerCase();
              skip();

              if (s[i] === "(") {
                i++; // (
                skip();

                if (lname === "calccycle") {
                  skip();
                  if (s[i] !== ")") return null;
                  i++;
                  return CALC_CYCLE_SECONDS;
                }

                if (lname === "getvalue") {
                  const varName = parseIdentifier();
                  if (!varName) return null;
                  skip();
                  const sep = s[i];
                  if (sep !== ";" && sep !== ",") return null;
                  i++;
                  const fallback = parseAddSub();
                  skip();
                  if (s[i] !== ")") return null;
                  i++;
                  const v = getSensorValueByToken(varName);
                  if (v == null) return fallback == null ? null : fallback;
                  return v;
                }

                // 1-arg math functions (demo)
                const arg1 = parseAddSub();
                skip();
                while (s[i] === ";" || s[i] === ",") {
                  i++;
                  parseAddSub(); // ignore extra args
                  skip();
                }
                if (s[i] !== ")") return null;
                i++;
                if (arg1 == null) return null;

                if (lname === "sqrt") return Math.sqrt(arg1);
                if (lname === "log") return Math.log(arg1);
                if (lname === "exp") return Math.exp(arg1);
                if (lname === "abs") return Math.abs(arg1);
                if (lname === "floor") return Math.floor(arg1);
                if (lname === "ceil") return Math.ceil(arg1);

                return null;
              }

              return getSensorValueByToken(name);
            }

            return null;
          }

          function parseMulDiv() {
            let v = parsePrimary();
            if (v == null) return null;
            while (true) {
              skip();
              const op = s[i];
              if (op !== "*" && op !== "/") break;
              i++;
              const r = parsePrimary();
              if (r == null) return null;
              v = op === "*" ? v * r : v / r;
              if (!Number.isFinite(v)) return null;
            }
            return v;
          }

          function parseAddSub() {
            let v = parseMulDiv();
            if (v == null) return null;
            while (true) {
              skip();
              const op = s[i];
              if (op !== "+" && op !== "-") break;
              i++;
              const r = parseMulDiv();
              if (r == null) return null;
              v = op === "+" ? v + r : v - r;
              if (!Number.isFinite(v)) return null;
            }
            return v;
          }

          const out = parseAddSub();
          skip();
          if (out == null) return null;
          if (i < s.length) return null;
          return Number.isFinite(out) ? out : null;
        }

        return evalNumericExpression(expr);
      }

      function refreshCalcPreviewIfOpen() {
        const modal = byId("modalBackdrop");
        if (!modal?.classList.contains("active")) return;
        const wrap = byId("typeFields");
        const preview = wrap?.querySelector("#fCalcPreview");
        const formulaEl = wrap?.querySelector("#fCalcFormula");
        const unitEl = wrap?.querySelector("#fCalcUnit");
        if (!preview || !formulaEl) return;

        const val = evalFormulaWithSensors(formulaEl.value);
        const unit = unitEl?.value?.trim() || "";
        preview.textContent = val == null ? "Prévisualisation : —" : `Prévisualisation : ${formatValue(val)}${unit ? " " + unit : ""}`;
      }

      // ===== Formula editor modal (MFCS-like, demo) =====
      const fxState = {
        open: false,
        kind: "condition", // condition | calc
        onCommit: null,
        returnFocus: null,
      };

      // ===== SELECT VARIABLE (demo) =====
      const varState = {
        mode: "parameter", // parameter | condition | calc
        target: null,
        selectedToken: null,
        filtered: [],
        returnFocus: null,
      };

      // ===== SELECT PHASE (Instrument phase) =====
      const phaseState = {
        target: null,
        selected: null,
        filtered: [],
        returnFocus: null,
        mode: "replace", // replace | insert
      };

      // ===== SELECT CALCULATION (Formula / Calculation) =====
      const calcState = {
        target: null,
        selected: null,
        filtered: [],
        returnFocus: null,
        mode: "replace", // replace | insert
      };

      function tokenKind(token) {
        const t = String(token || "");
        if (t.endsWith(".Setpoint")) return "Setpoint";
        if (t.endsWith(".Mode")) return "Mode";
        if (t.endsWith(".State")) return "State";
        if (t.endsWith(".Value")) return "Value";
        return "Variable";
      }

      function tokenSensorKey(token) {
        const base = String(token || "").split(".")[0] || "";
        if (base === "STIRR_1") return "STIRR";
        if (base === "O2_Flow") return "O2_Flow";
        if (base === "O2_Totalizer") return "O2_Totalizer";
        return base;
      }

      function tokenUnit(token) {
        const tok = String(token || "");
        const entry = variableCatalog.find((v) => v.token === tok);
        if (entry?.sensor && sensors[entry.sensor]) return sensors[entry.sensor].unit || "";
        const key = tokenSensorKey(tok);
        return sensors[key]?.unit || "";
      }

      function tokenExample(token) {
        const tok = String(token || "");
        if (tok.endsWith(".Setpoint")) {
          if (tok.startsWith("TEMP.")) return "37";
          if (tok.startsWith("pH.")) return "6.8";
          if (tok.startsWith("pO2.")) return "35";
          return "0";
        }
        if (tok.endsWith(".Mode")) return "auto";
        if (tok.endsWith(".State")) return "remote";
        return "";
      }

      function buildVarPickerTokens(mode) {
        const uniq = new Set(variableCatalog.map((v) => v.token));
        let tokens = Array.from(uniq);
        if (mode === "parameter") tokens = tokens.filter((t) => /\.(Setpoint|Mode|State)$/.test(t));
        if (mode === "condition") tokens = tokens.filter((t) => /\.Value$/.test(t));
        tokens.sort((a, b) => a.localeCompare(b));
        return tokens;
      }

      function renderVarPicker() {
        const list = byId("varList");
        if (!list) return;
        const q = String(byId("varSearch")?.value || "").trim().toLowerCase();
        list.innerHTML = "";

        const tokens = buildVarPickerTokens(varState.mode);
        const filtered = tokens.filter((t) => {
          if (!q) return true;
          const kind = tokenKind(t).toLowerCase();
          return t.toLowerCase().includes(q) || kind.includes(q);
        });
        varState.filtered = filtered;

        if (!filtered.length) {
          const empty = document.createElement("div");
          empty.className = "aiHint";
          empty.style.padding = "12px";
          empty.textContent = "Aucune variable trouvée.";
          list.appendChild(empty);
          return;
        }

        if (!varState.selectedToken || !filtered.includes(varState.selectedToken)) {
          varState.selectedToken = filtered[0] || null;
        }

        filtered.forEach((tok) => {
          const kind = tokenKind(tok);
          const unit = tokenUnit(tok);
          const ex = tokenExample(tok);
          const meta = ex ? `ex: ${ex}${unit ? " " + unit : ""}` : unit ? unit : "";

          const row = document.createElement("div");
          row.className = "varRow";
          row.dataset.token = tok;
          row.setAttribute("role", "option");
          row.setAttribute("aria-selected", "false");
          row.innerHTML = `
            <div style="min-width:0;">
              <div class="varName">${escapeHtml(tok)}</div>
              <div class="varMeta">${escapeHtml(meta)}</div>
            </div>
            <div class="varPill">${escapeHtml(kind)}</div>
            <div class="varMeta" style="text-align:right;">${escapeHtml(unit || "")}</div>
          `;

          row.addEventListener("click", () => {
            varPickerHighlight(tok);
          });
          row.addEventListener("dblclick", () => {
            varPickerHighlight(tok);
            commitVarPickerSelection();
          });

          list.appendChild(row);
        });
        varPickerHighlight(varState.selectedToken, { scrollIntoView: false });
      }

      function varPickerHighlight(token, { scrollIntoView } = {}) {
        const list = byId("varList");
        if (!list) return;
        const tok = token && String(token);
        if (!tok) return;
        varState.selectedToken = tok;
        let activeRow = null;
        list.querySelectorAll(".varRow").forEach((r) => {
          const active = r.dataset.token === tok;
          r.classList.toggle("selected", active);
          r.setAttribute("aria-selected", active ? "true" : "false");
          if (active) activeRow = r;
        });
        if (scrollIntoView !== false && activeRow) {
          activeRow.scrollIntoView({ block: "nearest" });
        }
      }

      function varPickerStep(delta) {
        const filtered = Array.isArray(varState.filtered) ? varState.filtered : [];
        if (!filtered.length) return;
        const cur = varState.selectedToken;
        let idx = filtered.indexOf(cur);
        if (idx < 0) idx = 0;
        idx = clamp(idx + delta, 0, filtered.length - 1);
        varPickerHighlight(filtered[idx], { scrollIntoView: true });
      }

      function commitVarPickerSelection() {
        const tok = varState.selectedToken;
        if (!tok) return;
        const target = varState.target && varState.target.isConnected ? varState.target : null;
        const ins = varState.mode === "parameter" ? `${tok}=` : tok;
        if (target && (target.tagName === "INPUT" || target.tagName === "TEXTAREA")) {
          target.focus();
          lastTextTarget = target;
          insertAtCaret(target, ins);
        } else {
          copyToClipboard(ins);
        }
        closeVarPicker({ restore: true });
      }

      function openVarPicker({ target, mode, title } = {}) {
        varState.mode = mode || "parameter";
        varState.target = target && (target.tagName === "INPUT" || target.tagName === "TEXTAREA") ? target : null;
        varState.returnFocus = varState.target || document.activeElement;
        varState.selectedToken = null;

        const t = byId("varTitle");
        if (t) t.textContent = title || "SELECT VARIABLE";
        const hint = byId("varHint");
        if (hint) {
          hint.textContent =
            varState.mode === "parameter"
              ? "Choisis un paramètre à écrire (Setpoint / Mode / State)."
              : "Choisis une variable à insérer.";
        }

        byId("varBackdrop")?.classList.add("active");
        updateModalLock();
        const search = byId("varSearch");
        if (search) {
          search.focus();
          search.setSelectionRange?.(0, search.value.length);
        }
        renderVarPicker();
      }

      function closeVarPicker({ restore } = {}) {
        byId("varBackdrop")?.classList.remove("active");
        varState.target = null;
        const el = restore ? varState.returnFocus : null;
        varState.returnFocus = null;
        if (el && el.focus) el.focus();
        updateModalLock();
      }

      // ===== SELECT PHASE (Instrument phase) =====
      function renderPhasePicker() {
        const list = byId("phaseList");
        if (!list) return;
        const q = String(byId("phaseSearch")?.value || "").trim().toLowerCase();
        list.innerHTML = "";

        const filtered = phaseCatalog.filter((p) => {
          if (!q) return true;
          return (
            String(p.name || "").toLowerCase().includes(q) ||
            String(p.unit || "").toLowerCase().includes(q) ||
            String(p.desc || "").toLowerCase().includes(q)
          );
        });
        phaseState.filtered = filtered.map((p) => p.name);

        if (!filtered.length) {
          const empty = document.createElement("div");
          empty.className = "aiHint";
          empty.style.padding = "12px";
          empty.textContent = "Aucune phase trouvée.";
          list.appendChild(empty);
          return;
        }

        if (!phaseState.selected || !phaseState.filtered.includes(phaseState.selected)) {
          phaseState.selected = phaseState.filtered[0] || null;
        }

        filtered.forEach((p) => {
          const row = document.createElement("div");
          row.className = "varRow";
          row.dataset.token = p.name;
          row.setAttribute("role", "option");
          row.setAttribute("aria-selected", "false");
          row.innerHTML = `
            <div style="min-width:0;">
              <div class="varName">${escapeHtml(p.name)}</div>
              <div class="varMeta">${escapeHtml(p.desc || "")}</div>
            </div>
            <div class="varPill">Phase</div>
            <div class="varMeta" style="text-align:right;">${escapeHtml(p.unit || "")}</div>
          `;
          row.addEventListener("click", () => phasePickerHighlight(p.name));
          row.addEventListener("dblclick", () => {
            phasePickerHighlight(p.name);
            commitPhasePickerSelection();
          });
          list.appendChild(row);
        });
        phasePickerHighlight(phaseState.selected, { scrollIntoView: false });
      }

      function phasePickerHighlight(token, { scrollIntoView } = {}) {
        const list = byId("phaseList");
        if (!list) return;
        const tok = token && String(token);
        if (!tok) return;
        phaseState.selected = tok;
        let activeRow = null;
        list.querySelectorAll(".varRow").forEach((r) => {
          const active = r.dataset.token === tok;
          r.classList.toggle("selected", active);
          r.setAttribute("aria-selected", active ? "true" : "false");
          if (active) activeRow = r;
        });
        if (scrollIntoView !== false && activeRow) activeRow.scrollIntoView({ block: "nearest" });
      }

      function phasePickerStep(delta) {
        const filtered = Array.isArray(phaseState.filtered) ? phaseState.filtered : [];
        if (!filtered.length) return;
        const cur = phaseState.selected;
        let idx = filtered.indexOf(cur);
        if (idx < 0) idx = 0;
        idx = clamp(idx + delta, 0, filtered.length - 1);
        phasePickerHighlight(filtered[idx], { scrollIntoView: true });
      }

      function commitPhasePickerSelection() {
        const tok = phaseState.selected;
        if (!tok) return;
        const target = phaseState.target && phaseState.target.isConnected ? phaseState.target : null;
        if (target && (target.tagName === "INPUT" || target.tagName === "TEXTAREA")) {
          if (phaseState.mode === "insert") {
            target.focus();
            lastTextTarget = target;
            insertAtCaret(target, tok);
          } else {
            target.value = tok;
            target.dispatchEvent(new Event("input", { bubbles: true }));
          }
        } else {
          copyToClipboard(tok);
        }
        closePhasePicker({ restore: true });
      }

      function openPhasePicker({ target, title } = {}) {
        phaseState.target = target && (target.tagName === "INPUT" || target.tagName === "TEXTAREA") ? target : null;
        phaseState.returnFocus = phaseState.target || document.activeElement;
        phaseState.mode = "replace";
        phaseState.selected = phaseState.target?.value?.trim() || null;

        const t = byId("phaseTitle");
        if (t) t.textContent = title || "SELECT PHASE";
        byId("phaseBackdrop")?.classList.add("active");
        updateModalLock();

        const search = byId("phaseSearch");
        if (search) {
          search.value = "";
          search.focus();
          search.setSelectionRange?.(0, search.value.length);
        }
        renderPhasePicker();
      }

      function closePhasePicker({ restore } = {}) {
        byId("phaseBackdrop")?.classList.remove("active");
        phaseState.target = null;
        const el = restore ? phaseState.returnFocus : null;
        phaseState.returnFocus = null;
        if (el && el.focus) el.focus();
        updateModalLock();
      }

      // ===== SELECT CALCULATION (Formula / Calculation) =====
      function renderCalcPicker() {
        const list = byId("calcList");
        if (!list) return;
        const q = String(byId("calcSearch")?.value || "").trim().toLowerCase();
        list.innerHTML = "";

        const filtered = calcCatalog.filter((c) => {
          if (!q) return true;
          return (
            String(c.name || "").toLowerCase().includes(q) ||
            String(c.short || "").toLowerCase().includes(q) ||
            String(c.desc || "").toLowerCase().includes(q)
          );
        });
        calcState.filtered = filtered.map((c) => c.name);

        if (!filtered.length) {
          const empty = document.createElement("div");
          empty.className = "aiHint";
          empty.style.padding = "12px";
          empty.textContent = "Aucun calcul trouvé.";
          list.appendChild(empty);
          return;
        }

        if (!calcState.selected || !calcState.filtered.includes(calcState.selected)) {
          calcState.selected = calcState.filtered[0] || null;
        }

        filtered.forEach((c) => {
          const row = document.createElement("div");
          row.className = "varRow";
          row.dataset.token = c.name;
          row.setAttribute("role", "option");
          row.setAttribute("aria-selected", "false");
          row.innerHTML = `
            <div style="min-width:0;">
              <div class="varName">${escapeHtml(c.name)}</div>
              <div class="varMeta">${escapeHtml(c.short || "")}</div>
            </div>
            <div class="varPill">Calc</div>
            <div class="varMeta" style="text-align:right;">${escapeHtml(c.desc || "")}</div>
          `;
          row.addEventListener("click", () => calcPickerHighlight(c.name));
          row.addEventListener("dblclick", () => {
            calcPickerHighlight(c.name);
            commitCalcPickerSelection();
          });
          list.appendChild(row);
        });
        calcPickerHighlight(calcState.selected, { scrollIntoView: false });
      }

      function calcPickerHighlight(token, { scrollIntoView } = {}) {
        const list = byId("calcList");
        if (!list) return;
        const tok = token && String(token);
        if (!tok) return;
        calcState.selected = tok;
        let activeRow = null;
        list.querySelectorAll(".varRow").forEach((r) => {
          const active = r.dataset.token === tok;
          r.classList.toggle("selected", active);
          r.setAttribute("aria-selected", active ? "true" : "false");
          if (active) activeRow = r;
        });
        if (scrollIntoView !== false && activeRow) activeRow.scrollIntoView({ block: "nearest" });
      }

      function calcPickerStep(delta) {
        const filtered = Array.isArray(calcState.filtered) ? calcState.filtered : [];
        if (!filtered.length) return;
        const cur = calcState.selected;
        let idx = filtered.indexOf(cur);
        if (idx < 0) idx = 0;
        idx = clamp(idx + delta, 0, filtered.length - 1);
        calcPickerHighlight(filtered[idx], { scrollIntoView: true });
      }

      function commitCalcPickerSelection() {
        const tok = calcState.selected;
        if (!tok) return;
        const target = calcState.target && calcState.target.isConnected ? calcState.target : null;
        if (target && (target.tagName === "INPUT" || target.tagName === "TEXTAREA")) {
          if (calcState.mode === "insert") {
            target.focus();
            lastTextTarget = target;
            insertAtCaret(target, tok);
          } else {
            target.value = tok;
            target.dispatchEvent(new Event("input", { bubbles: true }));
          }
        } else {
          copyToClipboard(tok);
        }
        closeCalcPicker({ restore: true });
      }

      function openCalcPicker({ target, title, mode } = {}) {
        calcState.target = target && (target.tagName === "INPUT" || target.tagName === "TEXTAREA") ? target : null;
        calcState.returnFocus = calcState.target || document.activeElement;
        calcState.mode = mode === "insert" ? "insert" : "replace";
        calcState.selected = calcState.target?.value?.trim() || null;

        const t = byId("calcTitle");
        if (t) t.textContent = title || "SELECT CALCULATION";
        byId("calcBackdrop")?.classList.add("active");
        updateModalLock();

        const search = byId("calcSearch");
        if (search) {
          search.value = "";
          search.focus();
          search.setSelectionRange?.(0, search.value.length);
        }
        renderCalcPicker();
      }

      function closeCalcPicker({ restore } = {}) {
        byId("calcBackdrop")?.classList.remove("active");
        calcState.target = null;
        const el = restore ? calcState.returnFocus : null;
        calcState.returnFocus = null;
        if (el && el.focus) el.focus();
        updateModalLock();
      }

      function setFxOpen(open) {
        fxState.open = !!open;
        byId("formulaBackdrop")?.classList.toggle("active", !!open);
        if (open) {
          fxState.returnFocus = document.activeElement;
        } else {
          const el = fxState.returnFocus;
          fxState.returnFocus = null;
          fxState.onCommit = null;
          if (el && el.isConnected && el.focus) el.focus();
        }
        updateModalLock();
      }

      function closeFormulaEditor() {
        setFxOpen(false);
      }

      function normalizeDotSpacing(expr) {
        return String(expr || "").replace(/([A-Za-z0-9_])\s*\.\s*([A-Za-z0-9_])/g, "$1.$2");
      }

      function normalizeEqualityOperators(expr) {
        const s = String(expr || "");
        let out = "";
        for (let i = 0; i < s.length; i++) {
          const ch = s[i];
          if (ch !== "=") {
            out += ch;
            continue;
          }
          const prev = s[i - 1] || "";
          const next = s[i + 1] || "";
          if (prev === "<" || prev === ">" || prev === "!" || prev === "=") {
            out += "=";
            continue;
          }
          if (next === "=") {
            out += "=";
            continue;
          }
          out += "==";
        }
        return out;
      }

      function safeEvalBooleanExpression(expr) {
        const normalized = String(expr || "").replaceAll(",", ".").trim();
        if (!normalized) return null;
        if (/[^0-9+\-*/().<>=!&| \t]/.test(normalized)) return null;
        try {
          const val = Function(`"use strict"; return !!(${normalized});`)();
          return typeof val === "boolean" ? val : null;
        } catch {
          return null;
        }
      }

      function evalConditionWithSensors(condition) {
        let expr = String(condition || "").trim();
        if (!expr) return null;
        expr = expr.replaceAll("×", "*").replaceAll("%", "");
        expr = normalizeDotSpacing(expr);
        expr = expr.replace(/\bAND\b/gi, "&&").replace(/\bOR\b/gi, "||").replace(/\bNOT\b/gi, "!");
        expr = normalizeEqualityOperators(expr);

        const tokens = variableCatalog
          .filter((v) => v.sensor)
          .map((v) => v.token)
          .sort((a, b) => b.length - a.length);
        tokens.forEach((t) => {
          const v = getSensorValueByToken(t);
          if (v == null) return;
          expr = expr.split(t).join(String(v));
        });

        return safeEvalBooleanExpression(expr);
      }

      function fxUpdatePreview() {
        const el = byId("fxText");
        const preview = byId("fxPreview");
        if (!el || !preview) return;
        const raw = el.value || "";

        if (fxState.kind === "calc") {
          const val = evalFormulaWithSensors(raw);
          preview.textContent = val == null ? "Prévisualisation : —" : `Prévisualisation : ${formatValue(val)}`;
          return;
        }

        const ok = evalConditionWithSensors(raw);
        preview.textContent = ok == null ? "Prévisualisation : —" : `Prévisualisation : ${ok ? "TRUE" : "FALSE"}`;
      }

      function fxInsert(text, { spaced } = {}) {
        const el = byId("fxText");
        if (!el) return;
        el.focus();
        lastTextTarget = el;
        const t = spaced ? ` ${text} ` : text;
        insertAtCaret(el, t);
      }

      function renderFxVars(filterText) {
        const list = byId("fxVars");
        if (!list) return;
        const q = String(filterText || "").trim().toLowerCase();
        list.innerHTML = "";

        const vars = variableCatalog
          .filter((v) => v.sensor)
          .map((v) => v.token)
          .sort((a, b) => a.localeCompare(b));

        vars
          .filter((t) => !q || t.toLowerCase().includes(q))
          .slice(0, 28)
          .forEach((tok) => {
            const btn = document.createElement("button");
            btn.className = "fxBtn";
            btn.type = "button";
            btn.textContent = tok;
            btn.title = "Insérer";
            btn.addEventListener("click", () => fxInsert(tok));
            list.appendChild(btn);
          });
      }

      function renderFxButtons() {
        const funcs = byId("fxFuncs");
        const ops = byId("fxOps");
        const nums = byId("fxNums");
        if (!funcs || !ops || !nums) return;

        funcs.innerHTML = "";
        ops.innerHTML = "";
        nums.innerHTML = "";

        const funcKeys = [
          { t: "getValue(", hint: "getValue(VAR;0)" },
          { t: "calcCycle()", hint: "calcCycle()" },
          { t: "sqrt(", hint: "sqrt(x)" },
          { t: "log(", hint: "log(x)" },
          { t: "exp(", hint: "exp(x)" },
          { t: "abs(", hint: "abs(x)" },
          { t: "floor(", hint: "floor(x)" },
          { t: "ceil(", hint: "ceil(x)" },
        ];
        funcKeys.forEach((k) => {
          const btn = document.createElement("button");
          btn.className = "fxBtn";
          btn.type = "button";
          btn.textContent = k.t.replace("(", "");
          btn.title = k.hint;
          btn.addEventListener("click", () => fxInsert(k.t));
          funcs.appendChild(btn);
        });

        const opKeys =
          fxState.kind === "calc"
            ? ["(", ")", "+", "-", "×", "/", ","]
            : ["(", ")", "<", ">", "<=", ">=", "=", "!=", "AND", "OR", "NOT"];
        opKeys.forEach((k) => {
          const btn = document.createElement("button");
          btn.className = "fxBtn muted";
          btn.type = "button";
          btn.textContent = k;
          const spaced = /^(AND|OR|NOT|<|>|<=|>=|=|!=)$/.test(k);
          btn.addEventListener("click", () => fxInsert(k, { spaced }));
          ops.appendChild(btn);
        });

        const keys = ["7", "8", "9", "/", "4", "5", "6", "×", "1", "2", "3", "-", "0", ".", "+", "⌫", "CLR", "SPACE", "(", ")"];
        keys.forEach((k) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "fxKey";
          if (k === "CLR" || k === "⌫") btn.classList.add("danger");
          if (k === "SPACE") btn.classList.add("wide");
          btn.textContent = k === "SPACE" ? "␠" : k;
          btn.addEventListener("click", () => {
            const el = byId("fxText");
            if (!el) return;
            el.focus();
            lastTextTarget = el;
            if (k === "CLR") {
              el.value = "";
              el.dispatchEvent(new Event("input", { bubbles: true }));
              return;
            }
            if (k === "⌫") {
              const start = el.selectionStart ?? el.value.length;
              const end = el.selectionEnd ?? el.value.length;
              if (start !== end) {
                el.value = el.value.slice(0, start) + el.value.slice(end);
                el.setSelectionRange?.(start, start);
              } else if (start > 0) {
                el.value = el.value.slice(0, start - 1) + el.value.slice(start);
                el.setSelectionRange?.(start - 1, start - 1);
              }
              el.dispatchEvent(new Event("input", { bubbles: true }));
              return;
            }
            if (k === "SPACE") {
              insertAtCaret(el, " ");
              return;
            }
            insertAtCaret(el, k);
          });
          nums.appendChild(btn);
        });
      }

      function openFormulaEditor({ kind, title, hint, value, onCommit } = {}) {
        fxState.kind = kind === "calc" ? "calc" : "condition";
        fxState.onCommit = typeof onCommit === "function" ? onCommit : null;

        byId("fxTitle").textContent = title || (fxState.kind === "calc" ? "Formula editor" : "EDIT CONDITION");
        byId("fxModeLabel").textContent = fxState.kind === "calc" ? "EDIT FORMULA" : "EDIT CONDITION";
        byId("fxFieldLabel").textContent = fxState.kind === "calc" ? "FORMULA" : "CONDITION";
        byId("fxHint").textContent =
          hint ||
          (fxState.kind === "calc"
            ? "Exemple PDF : Totalizer_O2 = getValue(O2_Totalizer.Value;0) + O2_Flow.Value × (calcCycle() / 60)"
            : "Astuce : AND / OR / NOT, comparateurs (<, >, <=, >=, =, !=) et variables capteur.");

        const legend = byId("fxLegend");
        if (legend) {
          const s = Object.values(sensors)
            .slice(0, 6)
            .map((v) => `${v.label}=${formatValue(Number(v.value))}${v.unit || ""}`)
            .join(" • ");
          legend.textContent = s ? `Capteurs: ${s}` : "";
        }

        const text = byId("fxText");
        if (text) {
          text.value = String(value || "");
          lastTextTarget = text;
          text.focus();
          text.setSelectionRange?.(text.value.length, text.value.length);
        }

        renderFxVars(byId("fxVarSearch")?.value || "");
        renderFxButtons();
        fxUpdatePreview();
        setFxOpen(true);
      }

      function toggleCollapse(which) {
        if (which === "recipe") uiPrefs.collapseRecipe = !uiPrefs.collapseRecipe;
        if (which === "op") uiPrefs.collapseOp = !uiPrefs.collapseOp;
        if (which === "library") uiPrefs.collapseLibrary = !uiPrefs.collapseLibrary;
        savePrefs();
        applyPrefsToDom();
        clampNodesToCanvas();
        renderCanvas();
        syncSelection();
      }

      function updateCollapseButtons() {
        document.querySelectorAll("[data-collapse]").forEach((btn) => {
          const which = btn.dataset.collapse;
          const pressed =
            (which === "recipe" && uiPrefs.collapseRecipe) ||
            (which === "op" && uiPrefs.collapseOp) ||
            (which === "library" && uiPrefs.collapseLibrary);
          btn.setAttribute("aria-pressed", pressed ? "true" : "false");
        });

        const compact = byId("toolCompact");
        if (compact) {
          compact.classList.toggle("active", !!uiPrefs.compactNodes);
          compact.setAttribute("aria-pressed", uiPrefs.compactNodes ? "true" : "false");
        }

        const wide = byId("toolWide");
        if (wide) {
          wide.classList.toggle("active", !!uiPrefs.wideCanvas);
          wide.setAttribute("aria-pressed", uiPrefs.wideCanvas ? "true" : "false");
        }

        const hand = byId("toolHand");
        if (hand) {
          hand.classList.toggle("active", !!uiPrefs.handMode);
          hand.setAttribute("aria-pressed", uiPrefs.handMode ? "true" : "false");
        }
      }

      function freshOperations() {
        return [
          { id: "prep", name: "Preparation", nodes: [], edges: [] },
          { id: "inoc", name: "Inoculation", nodes: [], edges: [] },
          { id: "batch", name: "Batch", nodes: [], edges: [] },
        ];
      }

      function getOp(opId) {
        return state.operations.find((o) => o.id === opId);
      }
      function getCurrentOp() {
        return getOp(state.currentOpId);
      }
      function findNode(op, nodeId) {
        return op.nodes.find((n) => n.id === nodeId);
      }

      const STORE_KEY = "workflow_ui_store_v1";
      let persistQueued = false;

      function snapshot() {
        return JSON.stringify({
          recipeId: state.recipeId,
          recipeChecks: Array.from(state.recipeChecks),
          recipeCatalog,
          recipesStore: state.recipesStore || {},
          operations: state.operations,
          currentOpId: state.currentOpId,
        });
      }

      function loadStore() {
        try {
          return localStorage.getItem(STORE_KEY);
        } catch {
          return null;
        }
      }

      function saveStore() {
        try {
          localStorage.setItem(STORE_KEY, snapshot());
        } catch {
          // ignore
        }
      }

      function persistSoon() {
        if (persistQueued) return;
        persistQueued = true;
        const schedule = window.queueMicrotask || ((fn) => setTimeout(fn, 0));
        schedule(() => {
          persistQueued = false;
          saveStore();
        });
      }

      function saveHistory() {
        state.history.push(snapshot());
        if (state.history.length > 80) state.history.shift();
        state.future = [];
        persistSoon();
      }

      function restoreSnapshot(snapshotJson) {
        const snap = JSON.parse(snapshotJson);
        state.recipeId = snap.recipeId;
        state.recipeChecks = new Set(snap.recipeChecks || []);

        if (Array.isArray(snap.recipeCatalog)) {
          recipeCatalog.length = 0;
          recipeCatalog.push(...snap.recipeCatalog);
        }
        state.recipesStore = snap.recipesStore || {};

        state.operations = snap.operations;
        state.currentOpId = snap.currentOpId || snap.operations?.[0]?.id || "prep";
        state.selection = { nodeId: null, nodeIds: new Set() };
        state.connectMode = { fromNodeId: null, pointer: null, cancelToken: state.connectMode.cancelToken };
        state.snapLink = { draggingId: null, inFromId: null, outToId: null, armedAt: 0, armTimer: 0 };
        renderAll();
        persistSoon();
      }

      function stashCurrentRecipe() {
        state.recipesStore = state.recipesStore || {};
        state.recipesStore[state.recipeId] = {
          operations: deepClone(state.operations),
          currentOpId: state.currentOpId,
        };
      }

      function loadRecipe(recipeId) {
        state.recipesStore = state.recipesStore || {};
        const saved = state.recipesStore[recipeId];
        if (saved?.operations?.length) {
          state.operations = deepClone(saved.operations);
          state.currentOpId = saved.currentOpId || saved.operations[0]?.id || "prep";
        } else {
          state.operations = freshOperations();
          state.currentOpId = "prep";
        }
      }

      function switchRecipe(recipeId) {
        if (!recipeId || recipeId === state.recipeId) return;
        saveHistory();
        stashCurrentRecipe();
        state.recipeId = recipeId;
        loadRecipe(recipeId);
        state.selection = { nodeId: null, nodeIds: new Set() };
        cancelConnect();
        renderAll();
        persistSoon();
      }

      function deleteRecipe(recipeId) {
        const id = recipeId || state.recipeId;
        const idx = recipeCatalog.findIndex((r) => r.id === id);
        if (idx < 0) return;
        const r = recipeCatalog[idx];
        if (recipeCatalog.length <= 1) {
          alert("Impossible de supprimer la dernière recette.");
          return;
        }
        const ok = confirm(`Supprimer la recette "${r.name}" ?`);
        if (!ok) return;

        saveHistory();
        stashCurrentRecipe();

        recipeCatalog.splice(idx, 1);
        state.recipeChecks?.delete?.(id);
        if (state.recipesStore) delete state.recipesStore[id];

        if (state.recipeId === id) {
          const next = recipeCatalog[Math.min(idx, recipeCatalog.length - 1)]?.id || recipeCatalog[0]?.id;
          state.recipeId = next || recipeCatalog[0]?.id;
          loadRecipe(state.recipeId);
          state.selection = { nodeId: null, nodeIds: new Set() };
          cancelConnect();
        }

        renderAll();
        persistSoon();
      }

      function deleteOperation(opId) {
        const id = opId || state.currentOpId;
        const idx = state.operations.findIndex((o) => o.id === id);
        if (idx < 0) return;
        if (state.operations.length <= 1) {
          alert("Impossible de supprimer la dernière opération.");
          return;
        }
        const op = state.operations[idx];
        const ok = confirm(`Supprimer l’opération "${op.name}" ?`);
        if (!ok) return;

        saveHistory();
        state.operations.splice(idx, 1);

        if (state.currentOpId === id) {
          const next = state.operations[Math.min(idx, state.operations.length - 1)]?.id || state.operations[0]?.id;
          state.currentOpId = next || state.operations[0]?.id;
        }

        state.selection = { nodeId: null, nodeIds: new Set() };
        cancelConnect();
        renderOperations();
        renderWorkspaceHeader();
        renderCanvas();
        syncSelection();
        persistSoon();
      }

      function getCanvasBounds() {
        // World bounds (pseudo-infinite canvas for the demo)
        return { minX: 0, minY: 0, maxX: 12000, maxY: 12000 };
      }

      function clampNodesToCanvas() {
        const bounds = getCanvasBounds();
        state.operations.forEach((op) => {
          op.nodes.forEach((n) => {
            n.x = clamp(n.x, bounds.minX, bounds.maxX);
            n.y = clamp(n.y, bounds.minY, bounds.maxY);
          });
        });
      }

      function autoLayoutCurrentOp(direction) {
        const op = getCurrentOp();
        if (!op || !op.nodes.length) return;
        const dir = direction === "v" ? "v" : "h";
        const rect = dom.canvas.getBoundingClientRect();
        const padding = 40;
        const viewZoom = getView().zoom || 1;
        const viewTopLeft = screenToWorld({ x: 0, y: 0 });
        const viewW = rect.width / viewZoom;
        const viewH = rect.height / viewZoom;

        const nodeW = dir === "v" ? 320 : 260;
        const nodeH =
          dir === "v"
            ? uiPrefs.compactNodes
              ? 66
              : 74
            : uiPrefs.compactNodes
              ? 54
              : 60;

        const out = new Map();
        const indeg = new Map(op.nodes.map((n) => [n.id, 0]));
        (op.edges || []).forEach((e) => {
          if (e.from === e.to) return;
          if (!out.has(e.from)) out.set(e.from, []);
          out.get(e.from).push(e.to);
          indeg.set(e.to, (indeg.get(e.to) || 0) + 1);
        });

        // Prefer Start as the single entry. This also avoids "everything is a root"
        // (e.g. nodes not connected yet), which would otherwise collapse to one column.
        let roots = op.nodes.filter((n) => n.type === "start");
        if (!roots.length) roots = op.nodes.filter((n) => (indeg.get(n.id) || 0) === 0);
        roots.sort((a, b) => (a.y ?? 0) - (b.y ?? 0));
        if (!roots.length) roots.push(op.nodes[0]);

        const depth = new Map();
        const queue = [];
        roots.forEach((r) => {
          depth.set(r.id, 0);
          queue.push(r.id);
        });

        while (queue.length) {
          const id = queue.shift();
          const d = depth.get(id) ?? 0;
          (out.get(id) || []).forEach((toId) => {
            const nd = d + 1;
            const prev = depth.get(toId);
            if (prev == null || nd < prev) {
              depth.set(toId, nd);
              queue.push(toId);
            }
          });
        }

        let maxDepth = 0;
        depth.forEach((d) => {
          if (d > maxDepth) maxDepth = d;
        });
        op.nodes.forEach((n) => {
          if (!depth.has(n.id)) {
            maxDepth += 1;
            depth.set(n.id, maxDepth);
          }
        });

        const groups = new Map();
        op.nodes.forEach((n) => {
          const d = depth.get(n.id) ?? 0;
          if (!groups.has(d)) groups.set(d, []);
          groups.get(d).push(n);
        });

        const sortedDepths = Array.from(groups.keys()).sort((a, b) => a - b);
        const axisKey = dir === "v" ? "x" : "y";
        sortedDepths.forEach((d) => {
          groups.get(d).sort((a, b) => (a[axisKey] ?? 0) - (b[axisKey] ?? 0));
        });

        // Keep comfortable spacing, even if it goes beyond the viewport (pan/zoom).
        const baseXGap =
          dir === "v"
            ? uiPrefs.compactNodes
              ? 120
              : 150
            : uiPrefs.compactNodes
              ? 180
              : 220;
        const baseYGap =
          dir === "v"
            ? uiPrefs.compactNodes
              ? 160
              : 210
            : uiPrefs.compactNodes
              ? 110
              : 150;
        const xGap = baseXGap;
        const yGap = baseYGap;

        saveHistory();
        uiPrefs.lastLayout = dir;
        savePrefs();
        applyPrefsToDom();

        if (dir === "v") {
          sortedDepths.forEach((d) => {
            const row = groups.get(d);
            const y = viewTopLeft.y + padding + d * (nodeH + yGap);
            const totalW = row.length * nodeW + Math.max(0, row.length - 1) * xGap;
            const startX = viewTopLeft.x + Math.max(padding, (viewW - totalW) / 2);
            row.forEach((n, i) => {
              n.x = startX + i * (nodeW + xGap);
              n.y = y;
            });
          });
        } else {
          sortedDepths.forEach((d) => {
            const col = groups.get(d);
            const x = viewTopLeft.x + padding + d * (nodeW + xGap);
            const totalH = col.length * nodeH + Math.max(0, col.length - 1) * yGap;
            const startY = viewTopLeft.y + Math.max(padding, (viewH - totalH) / 2);
            col.forEach((n, i) => {
              n.x = x;
              n.y = startY + i * (nodeH + yGap);
            });
          });
        }

        clampNodesToCanvas();
        renderCanvas();
        syncSelection();
        persistSoon();
      }

      function seedLikeImage() {
        // Rich recipe seed
        state.operations = [
          {
            id: "prep", name: "Preparation",
            nodes: [
              { id: "s1", type: "start", title: "Start", sub: "", x: 80, y: 200, data: { mode: "Automatic" } },
              { id: "p1", type: "parameter", title: "Set temperature and pH", sub: "TEMP 37\u00B0C \u00B7 pH 6.8", x: 300, y: 140,
                data: { mode: "Automatic", parameters: ["TEMP.State=remote","TEMP.Mode=auto","TEMP.Setpoint=37","pH.State=remote","pH.Mode=auto","pH.Setpoint=6.8"] } },
              { id: "pf1", type: "profile", title: "Temp ramp", sub: "TEMP 25\u2192 37\u00B0C / 15 min", x: 300, y: 280,
                data: { mode: "Automatic", variable: "TEMP", interpolation: "Linear", unit: "min", points: [{t:0,v:25},{t:15,v:37}] } },
              { id: "w1", type: "wait", title: "Wait 45 min", sub: "Dur\u00E9e 45 min", x: 580, y: 190, data: { mode: "Automatic", duration: 45, unit: "min" } },
              { id: "e1", type: "end", title: "End", sub: "", x: 820, y: 200, data: { mode: "Automatic" } },
            ],
            edges: [
              { id: "e1a", from: "s1", to: "p1" },
              { id: "e1b", from: "s1", to: "pf1" },
              { id: "e2a", from: "p1", to: "w1" },
              { id: "e2b", from: "pf1", to: "w1" },
              { id: "e3a", from: "w1", to: "e1" },
            ]
          },
          {
            id: "inoc", name: "Inoculation",
            nodes: [
              { id: "is1", type: "start", title: "Start", sub: "", x: 80, y: 200, data: { mode: "Automatic" } },
              { id: "iop", type: "operator", title: "Inoculate", sub: "Semi-Automatic", x: 320, y: 190,
                data: { mode: "Semi-Automatic", decisions: ["OK","Annuler"], message: "Inoculer le bior\u00E9acteur puis confirmer." } },
              { id: "ie1", type: "end", title: "End", sub: "", x: 580, y: 200, data: { mode: "Automatic" } },
            ],
            edges: [
              { id: "ie1a", from: "is1", to: "iop" },
              { id: "ie2a", from: "iop", to: "ie1" },
            ]
          },
          {
            id: "batch", name: "Batch",
            nodes: [
              { id: "bs1", type: "start", title: "Start", sub: "", x: 60, y: 200, data: { mode: "Automatic" } },
              { id: "bw1", type: "wait", title: "Wait 1 min", sub: "Dur\u00E9e 1 min", x: 260, y: 190, data: { mode: "Automatic", duration: 1, unit: "min" } },
              { id: "bp1", type: "parameter", title: "Activate pO2 control", sub: "pO2 35%", x: 500, y: 120,
                data: { mode: "Automatic", parameters: ["pO2.State=remote","pO2.Mode=auto","pO2.Setpoint=35"] } },
              { id: "bcalc", type: "calc", title: "Calculate OUR", sub: "OUR = pO2 feed", x: 500, y: 280,
                data: { mode: "Automatic", target: "OUR", unit: "mmol/L/h", formula: "(pO2.Value * O2_Flow.Value) / 1000" } },
              { id: "be1", type: "end", title: "End", sub: "", x: 760, y: 200, data: { mode: "Automatic" } },
            ],
            edges: [
              { id: "be1a", from: "bs1", to: "bw1", condition: "pO2.Value < 35%" },
              { id: "be2a", from: "bw1", to: "bp1", condition: "pO2.Value < 35%" },
              { id: "be3a", from: "bw1", to: "bw1", condition: "pO2.Value >= 35%" },
              { id: "be4a", from: "bp1", to: "bcalc" },
              { id: "be5a", from: "bcalc", to: "be1" },
            ]
          }
        ];
        state.currentOpId = "prep";
      }

      function renderAll() {
        renderRecipes();
        renderOperations();
        renderWorkspaceHeader();
        renderLibrary();
        renderCanvas();
        syncSelection();
      }

      function renderRecipes() {
        const list = byId("recipeList");
        const q = (byId("recipeSearch").value || "").trim().toLowerCase();
        const checkMode = byId("checkMode").checked;
        list.innerHTML = "";
        recipeCatalog
          .filter((r) => !q || r.name.toLowerCase().includes(q))
          .forEach((r) => {
            const row = document.createElement("div");
            row.className = "listItem" + (state.recipeId === r.id ? " active" : "");
            row.setAttribute("role", "option");
            row.setAttribute("aria-selected", state.recipeId === r.id ? "true" : "false");
            const checked = state.recipeChecks.has(r.id);
            row.innerHTML = `
              <div style="min-width:0;display:flex;align-items:center;gap:10px;">
                ${checkMode ? `<input type="checkbox" ${checked ? "checked" : ""} aria-label="Sélection" />` : ""}
                <div style="min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${escapeHtml(r.name)}</div>
              </div>
              <button class="kebab" title="Menu" aria-label="Menu">
                <svg viewBox="0 0 24 24" fill="none"><path d="M12 6.5h.01M12 12h.01M12 17.5h.01" stroke="currentColor" stroke-width="3" stroke-linecap="round"/></svg>
              </button>
            `;

            const checkbox = row.querySelector('input[type="checkbox"]');
            if (checkbox) {
              checkbox.addEventListener("click", (e) => {
                e.stopPropagation();
                saveHistory();
                if (checkbox.checked) state.recipeChecks.add(r.id);
                else state.recipeChecks.delete(r.id);
              });
            }

            const kebab = row.querySelector(".kebab");
            if (kebab) {
              kebab.addEventListener("click", (e) => {
                e.stopPropagation();
                state.uiFocusArea = "recipe";
                deleteRecipe(r.id);
              });
            }

            row.addEventListener("click", (e) => {
              if (e.target.closest(".kebab")) return;
              state.uiFocusArea = "recipe";
              switchRecipe(r.id);
            });
            list.appendChild(row);
          });
      }

      function renderOperations() {
        const container = byId("operationList");
        container.innerHTML = "";
        state.operations.forEach((op, idx) => {
          const row = document.createElement("div");
          row.className = "opRow" + (state.currentOpId === op.id ? " active" : "");
          row.innerHTML = `
            <div class="opNum">${idx + 1}</div>
            <div style="min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${escapeHtml(op.name)}</div>
            <button class="kebab" style="margin-left:auto;" title="Supprimer" aria-label="Supprimer">
              <svg viewBox="0 0 24 24" fill="none"><path d="M12 6.5h.01M12 12h.01M12 17.5h.01" stroke="currentColor" stroke-width="3" stroke-linecap="round"/></svg>
            </button>
          `;

          const kebab = row.querySelector(".kebab");
          if (kebab) {
            kebab.addEventListener("click", (e) => {
              e.stopPropagation();
              state.uiFocusArea = "op";
              deleteOperation(op.id);
            });
          }

          row.addEventListener("click", (e) => {
            if (e.target.closest(".kebab")) return;
            state.uiFocusArea = "op";
            state.currentOpId = op.id;
            state.selection = { nodeId: null, nodeIds: new Set() };
            cancelConnect();
            renderOperations();
            renderWorkspaceHeader();
            renderCanvas();
            syncSelection();
          });
          container.appendChild(row);
        });
      }

      function renderWorkspaceHeader() {
        const idx = state.operations.findIndex((o) => o.id === state.currentOpId);
        byId("wsIndex").textContent = `${Math.max(0, idx) + 1}.`;
        byId("wsName").textContent = getCurrentOp()?.name || "Operation";
      }

      function renderLibrary() {
        const container = byId("libraryList");
        container.innerHTML = "";
        libraryItems.forEach((item) => {
          const lib = document.createElement("div");
          lib.className = "libItem";
          lib.setAttribute("draggable", "true");
          lib.dataset.type = item.type;
          const ic = iconByType[item.type] || { bg: "#94a3b8", label: "?" };
          lib.innerHTML = `
            <div class="libIcon" style="background:${ic.bg};">${escapeHtml(ic.label)}</div>
            <div style="display:flex;flex-direction:column;line-height:1.05;">
              <div class="libLabel">${escapeHtml(item.label)}</div>
              <small>${escapeHtml(item.hint)}</small>
            </div>
          `;
          lib.addEventListener("dragstart", (e) => {
            e.dataTransfer.setData("application/json", JSON.stringify(item));
            e.dataTransfer.effectAllowed = "copy";
          });
          container.appendChild(lib);
        });
      }

      function renderCanvas() {
        dom.nodeEls.forEach((el) => el.remove());
        dom.nodeEls.clear();
        dom.wires.innerHTML = "";
        dom.wires.setAttribute("width", "100%");
        dom.wires.setAttribute("height", "100%");

        const op = getCurrentOp();
        if (!op) return;

        op.nodes.forEach((node) => {
          const el = document.createElement("div");
          el.className = "node";
          el.style.left = `${node.x}px`;
          el.style.top = `${node.y}px`;
          el.dataset.id = node.id;

          const icon = iconByType[node.type] || { bg: "#94a3b8", label: "?" };
          const inDisabled = node.type === "start" ? "true" : "false";
          const outDisabled = node.type === "end" ? "true" : "false";
          el.innerHTML = `
            <div class="nodeIcon" style="background:${icon.bg};">${escapeHtml(icon.label)}</div>
            <div class="nodeText">
              <div class="nodeTitle">${escapeHtml(node.title)}</div>
              <div class="nodeSub">${escapeHtml(node.sub || "")}</div>
            </div>
            <div class="handle in" data-handle="in" data-disabled="${inDisabled}" title="Entrée"></div>
            <div class="handle out" data-handle="out" data-disabled="${outDisabled}" title="Sortie"></div>
          `;

          dom.nodesLayer.appendChild(el);
          dom.nodeEls.set(node.id, el);
          bindNodeInteractions(el, node);
        });

        updateWires();

        // --- Diff overlay ---
        if (typeof diffState !== "undefined" && diffState.active) {
          const diffOp = getCurrentOp();
          if (diffOp) {
            dom.nodeEls.forEach((el, id) => {
              const info = diffState.diffMap.get(id);
              if (!info || info.status === "unchanged") {
                el.classList.add("diff-unchanged");
              } else {
                el.classList.add("diff-" + info.status);
                const cls = info.status === "added" ? "added" : info.status === "removed" ? "removed" : "modified";
                const lbl = info.status === "added" ? "+" : info.status === "removed" ? "\u2212" : "\u0394";
                const badge = document.createElement("div");
                badge.className = "diffBadge " + cls;
                badge.textContent = lbl;
                el.appendChild(badge);
                if (info.desc) {
                  const tt = document.createElement("div");
                  tt.className = "diffTooltip";
                  tt.textContent = info.desc;
                  el.appendChild(tt);
                }
              }
            });
            // Ghost nodes for removed phases
            const oldOp = diffState.oldOps?.find(o => o.id === state.currentOpId);
            if (oldOp) {
              for (const [id, info] of diffState.diffMap) {
                if (info.status !== "removed") continue;
                const oldNode = oldOp.nodes.find(n => n.id === id);
                if (!oldNode) continue;
                const el = document.createElement("div");
                el.className = "node diff-removed";
                el.style.left = oldNode.x + "px";
                el.style.top = oldNode.y + "px";
                const icon = iconByType[oldNode.type] || { bg: "#94a3b8", label: "?" };
                el.innerHTML = `<div class="diffBadge removed">\u2212</div><div class="nodeIcon" style="background:${icon.bg};">${escapeHtml(icon.label)}</div><div class="nodeText"><div class="nodeTitle">${escapeHtml(oldNode.title)}</div><div class="nodeSub">${escapeHtml(oldNode.sub || "")}</div></div><div class="diffTooltip">Phase supprim\u00E9e</div>`;
                dom.nodesLayer.appendChild(el);
              }
            }
            // Restyle wires
            const oldEdgeSet = new Set();
            if (oldOp) oldOp.edges.forEach(e => oldEdgeSet.add(e.from + "|" + e.to));
            document.querySelectorAll("#wires path").forEach((path, i) => {
              if (!diffOp.edges[i]) return;
              const key = diffOp.edges[i].from + "|" + diffOp.edges[i].to;
              if (!oldEdgeSet.has(key)) {
                path.setAttribute("stroke", "#22c55e");
                path.setAttribute("stroke-width", "4");
                path.style.filter = "drop-shadow(0 0 3px rgba(34,197,94,0.5))";
              } else {
                path.style.opacity = "0.3";
              }
            });
          }
        }
      }

      function syncSelection() {
        dom.nodeEls.forEach((el, id) => {
          el.classList.toggle("selected", isSelected(id));
        });
      }

      function updateSnapHighlights() {
        const inFromId = state.snapLink.inFromId;
        const outToId = state.snapLink.outToId;
        dom.nodeEls.forEach((el, id) => {
          el.classList.toggle("snapTarget", id === inFromId || id === outToId);
        });
      }

      function setSnapLink({ draggingId, inFromId, outToId }) {
        const nextDraggingId = draggingId || null;
        const nextIn = inFromId || null;
        const nextOut = outToId || null;
        const changed =
          state.snapLink.draggingId !== nextDraggingId ||
          state.snapLink.inFromId !== nextIn ||
          state.snapLink.outToId !== nextOut;

        state.snapLink.draggingId = nextDraggingId;
        state.snapLink.inFromId = nextIn;
        state.snapLink.outToId = nextOut;

        if (changed) {
          state.snapLink.armedAt = nextIn || nextOut ? Date.now() : 0;
          if (state.snapLink.armTimer) clearTimeout(state.snapLink.armTimer);
          state.snapLink.armTimer = 0;
          if (nextIn || nextOut) {
            state.snapLink.armTimer = window.setTimeout(() => {
              updateWires();
              updateSnapHint();
            }, SNAP_ARM_MS + 10);
          }
        }
        updateSnapHighlights();
        updateSnapHint();
      }

      function clearSnapLink() {
        setSnapLink({ draggingId: null, inFromId: null, outToId: null });
      }

      function updateSnapHint() {
        const hint = dom.snapHint || byId("snapHint");
        if (!hint) return;
        dom.snapHint = hint;
        const id = state.snapLink.draggingId;
        const has = !!(state.snapLink.inFromId || state.snapLink.outToId);
        if (!id || !has) {
          hint.classList.remove("active");
          return;
        }
        const el = dom.nodeEls.get(id);
        if (!el) {
          hint.classList.remove("active");
          return;
        }
        const canvasRect = dom.canvas.getBoundingClientRect();
        const r = el.getBoundingClientRect();
        const x = r.left - canvasRect.left + r.width / 2;
        const y = r.top - canvasRect.top;
        const armed = !!state.snapLink.armedAt && Date.now() - state.snapLink.armedAt > SNAP_ARM_MS;
        hint.textContent = armed ? "Accroché ✓ — relâcher" : "Relâcher pour connecter";
        hint.style.left = `${x}px`;
        hint.style.top = `${y}px`;
        hint.classList.add("active");
      }

      function nodePointIn(el) {
        const canvasRect = dom.canvas.getBoundingClientRect();
        const r = el.getBoundingClientRect();
        const dir = effectiveWireDir();
        if (dir === "v") {
          return {
            x: r.left - canvasRect.left + r.width / 2,
            y: r.top - canvasRect.top - 10,
          };
        }
        return {
          x: r.left - canvasRect.left - 7,
          y: r.top - canvasRect.top + r.height / 2,
        };
      }

      function nodePointOut(el) {
        const canvasRect = dom.canvas.getBoundingClientRect();
        const r = el.getBoundingClientRect();
        const dir = effectiveWireDir();
        if (dir === "v") {
          return {
            x: r.left - canvasRect.left + r.width / 2,
            y: r.top - canvasRect.top + r.height + 10,
          };
        }
        return {
          x: r.left - canvasRect.left + r.width + 7,
          y: r.top - canvasRect.top + r.height / 2,
        };
      }

      function dist(a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        return Math.hypot(dx, dy);
      }

      function computeSnapCandidates(dragNodeId, { excludeIds } = {}) {
        const op = getCurrentOp();
        if (!op) return { inFromId: null, outToId: null };
        const dragNode = findNode(op, dragNodeId);
        const dragEl = dom.nodeEls.get(dragNodeId);
        if (!dragNode || !dragEl) return { inFromId: null, outToId: null };
        const excluded = excludeIds instanceof Set ? excludeIds : null;

        const dragIn = nodePointIn(dragEl);
        const dragOut = nodePointOut(dragEl);

        const SNAP_DIST = 92;
        let bestIn = { id: null, d: Infinity };
        let bestOut = { id: null, d: Infinity };

        for (const other of op.nodes) {
          if (other.id === dragNodeId) continue;
          if (excluded && excluded.has(other.id)) continue;
          const otherEl = dom.nodeEls.get(other.id);
          if (!otherEl) continue;

          if (other.type !== "end" && dragNode.type !== "start") {
            const d = dist(nodePointOut(otherEl), dragIn);
            if (d < bestIn.d) bestIn = { id: other.id, d };
          }
          if (dragNode.type !== "end" && other.type !== "start") {
            const d = dist(dragOut, nodePointIn(otherEl));
            if (d < bestOut.d) bestOut = { id: other.id, d };
          }
        }

        let inFromId = bestIn.d <= SNAP_DIST ? bestIn.id : null;
        let outToId = bestOut.d <= SNAP_DIST ? bestOut.id : null;

        if (inFromId && outToId && inFromId === outToId) {
          if (bestIn.d <= bestOut.d) outToId = null;
          else inFromId = null;
        }

        return { inFromId, outToId };
      }

      function updateSnapLinkDuringDrag(dragNodeId, { excludeIds } = {}) {
        if (!dragNodeId) {
          clearSnapLink();
          return;
        }
        if (state.connectMode.fromNodeId) {
          clearSnapLink();
          return;
        }

        const { inFromId, outToId } = computeSnapCandidates(dragNodeId, { excludeIds });
        if (!inFromId && !outToId) {
          clearSnapLink();
          return;
        }
        setSnapLink({ draggingId: dragNodeId, inFromId, outToId });
      }

      function updateWires() {
        dom.wires.innerHTML = "";
        const op = getCurrentOp();
        if (!op) return;

        op.edges.forEach((edge) => {
          const fromEl = dom.nodeEls.get(edge.from);
          const toEl = dom.nodeEls.get(edge.to);
          if (!fromEl || !toEl) return;
          drawEdge(fromEl, toEl, edge);
        });

        if (state.connectMode.fromNodeId && state.connectMode.pointer) {
          const fromEl = dom.nodeEls.get(state.connectMode.fromNodeId);
          if (fromEl) drawPreviewEdge(fromEl, state.connectMode.pointer);
        }

        // Auto-snap preview while dragging a node near another node
        if (state.snapLink.draggingId) {
          const dragEl = dom.nodeEls.get(state.snapLink.draggingId);
          if (dragEl) {
            const armed = !!state.snapLink.armedAt && Date.now() - state.snapLink.armedAt > SNAP_ARM_MS;
            const inFromEl = state.snapLink.inFromId ? dom.nodeEls.get(state.snapLink.inFromId) : null;
            const outToEl = state.snapLink.outToId ? dom.nodeEls.get(state.snapLink.outToId) : null;
            if (inFromEl) drawGhostEdge(inFromEl, dragEl, { armed });
            if (outToEl) drawGhostEdge(dragEl, outToEl, { armed });
          }
        }
      }

      function drawGhostEdge(fromEl, toEl, { armed } = {}) {
        const dir = effectiveWireDir();
        const p1 = nodePointOut(fromEl);
        const p2 = nodePointIn(toEl);

        let d;
        if (dir === "v") {
          const dy = p2.y - p1.y;
          const bend = clamp(Math.abs(dy) / 2, 60, 150);
          const s = dy >= 0 ? 1 : -1;
          const c1y = p1.y + s * bend;
          const c2y = p2.y - s * bend;
          d = `M ${p1.x} ${p1.y} C ${p1.x} ${c1y}, ${p2.x} ${c2y}, ${p2.x} ${p2.y}`;
        } else {
          const dx = p2.x - p1.x;
          const bend = clamp(Math.abs(dx) / 2, 60, 150);
          const s = dx >= 0 ? 1 : -1;
          const c1x = p1.x + s * bend;
          const c2x = p2.x - s * bend;
          d = `M ${p1.x} ${p1.y} C ${c1x} ${p1.y}, ${c2x} ${p2.y}, ${p2.x} ${p2.y}`;
        }

        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("d", d);
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", armed ? "rgba(16,185,129,0.9)" : "rgba(16,185,129,0.55)");
        path.setAttribute("stroke-width", armed ? "4" : "3");
        path.setAttribute("stroke-linecap", "round");
        if (!armed) path.setAttribute("stroke-dasharray", "6 6");
        dom.wires.appendChild(path);
      }

      function drawEdge(fromEl, toEl, edge) {
        const dir = effectiveWireDir();
        const canvasRect = dom.canvas.getBoundingClientRect();
        const a = fromEl.getBoundingClientRect();
        const fromId = fromEl.dataset.id;
        const toId = toEl.dataset.id;

        const p1 = nodePointOut(fromEl);
        const p2 = nodePointIn(toEl);
        const x1 = p1.x;
        const y1 = p1.y;
        const x2 = p2.x;
        const y2 = p2.y;

        let d;
        if (fromId === toId) {
          if (dir === "v") {
            const loopX = x1 + 120;
            const yMid = (y1 + y2) / 2;
            d = `M ${x1} ${y1}
                 C ${x1} ${y1 + 80}, ${loopX} ${y1 + 80}, ${loopX} ${yMid}
                 C ${loopX} ${y2 - 80}, ${x2} ${y2 - 80}, ${x2} ${y2}`;
          } else {
            const loopTop = y1 - 90;
            d = `M ${x1} ${y1} C ${x1 + 90} ${y1}, ${x1 + 90} ${loopTop}, ${(a.left - canvasRect.left) + 20} ${loopTop}
                 C ${(a.left - canvasRect.left) - 80} ${loopTop}, ${(a.left - canvasRect.left) - 80} ${y2}, ${x2} ${y2}`;
          }
        } else if (dir === "v") {
          const dy = y2 - y1;
          const bend = clamp(Math.abs(dy) / 2, 60, 160);
          const s = dy >= 0 ? 1 : -1;
          const c1y = y1 + s * bend;
          const c2y = y2 - s * bend;
          d = `M ${x1} ${y1} C ${x1} ${c1y}, ${x2} ${c2y}, ${x2} ${y2}`;
        } else {
          const dx = x2 - x1;
          const bend = clamp(Math.abs(dx) / 2, 60, 160);
          const s = dx >= 0 ? 1 : -1;
          const c1x = x1 + s * bend;
          const c2x = x2 - s * bend;
          d = `M ${x1} ${y1} C ${c1x} ${y1}, ${c2x} ${y2}, ${x2} ${y2}`;
        }

        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("d", d);
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", "#c7cdd8");
        path.setAttribute("stroke-width", "3");
        path.setAttribute("stroke-linecap", "round");
        dom.wires.appendChild(path);

        if (edge.condition) {
          const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
          label.setAttribute("fill", "#94a3b8");
          label.setAttribute("font-size", "11");
          label.setAttribute("font-weight", "900");
          label.setAttribute("text-anchor", "middle");
          label.setAttribute("dominant-baseline", "central");
          let lx;
          let ly;
          if (fromId === toId) {
            if (dir === "v") {
              lx = x1 + 120;
              ly = (y1 + y2) / 2;
            } else {
              lx = x1 + 40;
              ly = y1 - 88;
            }
          } else if (dir === "v") {
            lx = (x1 + x2) / 2 + 12;
            ly = (y1 + y2) / 2;
          } else {
            lx = (x1 + x2) / 2;
            ly = (y1 + y2) / 2 - 10;
          }
          label.setAttribute("x", String(lx));
          label.setAttribute("y", String(ly));
          label.textContent = edge.condition;
          dom.wires.appendChild(label);
        }
      }

      function drawPreviewEdge(fromEl, pointer) {
        const dir = effectiveWireDir();
        const p1 = nodePointOut(fromEl);
        const x1 = p1.x;
        const y1 = p1.y;
        const x2 = pointer.x;
        const y2 = pointer.y;
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");

        let d;
        if (dir === "v") {
          const dy = y2 - y1;
          const bend = clamp(Math.abs(dy) / 2, 60, 160);
          const s = dy >= 0 ? 1 : -1;
          const c1y = y1 + s * bend;
          const c2y = y2 - s * bend;
          d = `M ${x1} ${y1} C ${x1} ${c1y}, ${x2} ${c2y}, ${x2} ${y2}`;
        } else {
          const dx = x2 - x1;
          const bend = clamp(Math.abs(dx) / 2, 60, 160);
          const s = dx >= 0 ? 1 : -1;
          const c1x = x1 + s * bend;
          const c2x = x2 - s * bend;
          d = `M ${x1} ${y1} C ${c1x} ${y1}, ${c2x} ${y2}, ${x2} ${y2}`;
        }

        path.setAttribute("d", d);
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", "rgba(59,130,246,0.6)");
        path.setAttribute("stroke-width", "3");
        path.setAttribute("stroke-linecap", "round");
        path.setAttribute("stroke-dasharray", "6 6");
        dom.wires.appendChild(path);
      }

      function defaultDataForType(type) {
        if (type === "parameter") return { mode: "Automatic", description: "", parameters: [] };
        if (type === "wait") return { mode: "Automatic", description: "", duration: 1, unit: "min" };
        if (type === "operator") return { mode: "Automatic", description: "", decisions: ["OK"], message: "Décision opérateur." };
        if (type === "instrument") return { mode: "Automatic", description: "", phase: "", forceRestart: "No" };
        if (type === "profile") {
          return {
            mode: "Automatic",
            description: "",
            variable: "",
            interpolation: "Linear",
            unit: "min",
            points: [
              { t: 0, v: 0 },
              { t: 30, v: 100 },
            ],
          };
        }
        if (type === "calc") {
          return {
            mode: "Automatic",
            description: "",
            target: "",
            unit: "",
            formula: "pO2.Value - 35",
          };
        }
        return { mode: "Automatic", description: "" };
      }

      function bindDnD() {
        dom.canvas.addEventListener("dragover", (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = "copy";
        });
        dom.canvas.addEventListener("drop", (e) => {
          e.preventDefault();
          const raw = e.dataTransfer.getData("application/json");
          if (!raw) return;
          const item = JSON.parse(raw);
          const op = getCurrentOp();
          if (!op) return;
          const bounds = getCanvasBounds();
          const rect = dom.canvas.getBoundingClientRect();
          const screen = { x: e.clientX - rect.left, y: e.clientY - rect.top };
          const world = screenToWorld(screen);
          const x = world.x - 120;
          const y = world.y - 28;
          saveHistory();
          const id = uid("node");
          op.nodes.push({
            id,
            type: item.type,
            title: item.label.replace(" phase", "").trim(),
            sub: item.type === "wait" ? "Durée…" : "",
            x: clamp(x, bounds.minX, bounds.maxX),
            y: clamp(y, bounds.minY, bounds.maxY),
            data: defaultDataForType(item.type),
          });
          setSelectionSingle(id);
          renderCanvas();
          syncSelection();
        });
      }

      function bindCanvasViewport() {
        // Wheel: pan or zoom (Ctrl/⌘)
        dom.canvas.addEventListener(
          "wheel",
          (e) => {
            const active = document.activeElement;
            if (active && (active.tagName === "INPUT" || active.tagName === "TEXTAREA")) return;
            if (byId("modalBackdrop")?.classList.contains("active")) return;
            if (byId("formulaBackdrop")?.classList.contains("active")) return;
            if (byId("varBackdrop")?.classList.contains("active")) return;
            if (byId("phaseBackdrop")?.classList.contains("active")) return;
            if (byId("calcBackdrop")?.classList.contains("active")) return;
            if (byId("historyBackdrop")?.classList.contains("active")) return;

            e.preventDefault();
            const pt = canvasPointFromEvent(e);
            const v = getView();

            if (e.ctrlKey || e.metaKey) {
              const factor = Math.pow(1.0016, -e.deltaY);
              zoomAt(pt, v.zoom * factor, { save: false });
              return;
            }

            setView({ x: v.x - e.deltaX, y: v.y - e.deltaY, zoom: v.zoom }, { save: false });
          },
          { passive: false },
        );

        // Pan / box selection (React-Flow-like)
        dom.canvas.addEventListener("pointerdown", (e) => {
          if (e.button !== 0 && e.button !== 1) return;
          if (state.connectMode.fromNodeId) return;
          if (e.target.closest(".node")) return;
          state.uiFocusArea = "canvas";

          const pt = canvasPointFromEvent(e);
          const wantBox = e.button === 0 && !keyState.space && (e.shiftKey || !uiPrefs.handMode);
          const isPan = e.button === 1 || keyState.space || !wantBox;
          const additive = wantBox && (e.ctrlKey || e.metaKey);

          if (isPan) {
            const v = getView();
            canvasGesture.panning = { start: pt, view: { x: v.x, y: v.y, zoom: v.zoom }, moved: false, button: e.button };
            dom.canvas.classList.add("panning");
            e.preventDefault();
          } else {
            const base = additive ? new Set(Array.from(ensureSelectionSet())) : new Set();
            if (!additive) clearSelection();
            canvasGesture.boxing = { start: pt, base, additive, moved: false };
            if (dom.marquee) {
              dom.marquee.style.display = "block";
              dom.marquee.style.left = `${pt.x}px`;
              dom.marquee.style.top = `${pt.y}px`;
              dom.marquee.style.width = "0px";
              dom.marquee.style.height = "0px";
            }
          }

          const onMove = (ev) => {
            const cur = canvasPointFromEvent(ev);
            if (canvasGesture.panning) {
              const g = canvasGesture.panning;
              if (!g.moved && Math.hypot(cur.x - g.start.x, cur.y - g.start.y) > 2) g.moved = true;
              setView({ x: g.view.x + (cur.x - g.start.x), y: g.view.y + (cur.y - g.start.y), zoom: g.view.zoom }, { save: false });
              return;
            }

            if (canvasGesture.boxing) {
              const g = canvasGesture.boxing;
              const x1 = g.start.x;
              const y1 = g.start.y;
              const x2 = cur.x;
              const y2 = cur.y;
              const left = Math.min(x1, x2);
              const top = Math.min(y1, y2);
              const width = Math.abs(x2 - x1);
              const height = Math.abs(y2 - y1);
              if (width > 2 || height > 2) g.moved = true;

              if (dom.marquee) {
                dom.marquee.style.left = `${left}px`;
                dom.marquee.style.top = `${top}px`;
                dom.marquee.style.width = `${width}px`;
                dom.marquee.style.height = `${height}px`;
              }

              const canvasRect = dom.canvas.getBoundingClientRect();
              const hits = [];
              dom.nodeEls.forEach((el, id) => {
                const r = el.getBoundingClientRect();
                const nx = r.left - canvasRect.left;
                const ny = r.top - canvasRect.top;
                const nw = r.width;
                const nh = r.height;
                const intersects = nx < left + width && nx + nw > left && ny < top + height && ny + nh > top;
                if (intersects) hits.push(id);
              });

              const ids = new Set(g.base);
              hits.forEach((id) => ids.add(id));
              state.selection.nodeIds = ids;
              state.selection.nodeId = hits[hits.length - 1] || state.selection.nodeId || null;
              syncSelection();
              return;
            }
          };

          const onUp = () => {
            window.removeEventListener("pointermove", onMove);
            window.removeEventListener("pointerup", onUp);

            if (canvasGesture.panning) {
              const g = canvasGesture.panning;
              dom.canvas.classList.remove("panning");
              canvasGesture.panning = null;
              savePrefs();
              updateWires();
              if (!g.moved && g.button === 0) {
                clearSelection();
                syncSelection();
              }
              return;
            }

            if (canvasGesture.boxing) {
              const g = canvasGesture.boxing;
              canvasGesture.boxing = null;
              if (dom.marquee) dom.marquee.style.display = "none";
              if (!g.moved && !g.additive) {
                clearSelection();
                syncSelection();
              }
              return;
            }
          };

          window.addEventListener("pointermove", onMove);
          window.addEventListener("pointerup", onUp);
        });

        // Double click on background => fit view
        dom.canvas.addEventListener("dblclick", (e) => {
          if (e.target.closest(".node")) return;
          fitViewToOp(state.currentOpId);
        });
      }

      function bindNodeInteractions(el, node) {
        // handles: connect
        el.querySelectorAll(".handle").forEach((h) => {
          h.addEventListener("click", (e) => {
            e.stopPropagation();
            const disabled = h.dataset.disabled === "true";
            if (disabled) return;
            const kind = h.dataset.handle;
            if (kind === "out") startConnect(node.id);
            if (kind === "in") finishConnect(node.id);
          });
        });

        // edit
        el.addEventListener("dblclick", (e) => {
          e.stopPropagation();
          openEditor(node.id);
        });

        // select + drag
        el.addEventListener("pointerdown", (e) => {
          if (e.button !== 0) return;
          if (e.target.closest(".handle")) return;
          if (state.connectMode.fromNodeId) return;
          state.uiFocusArea = "canvas";

          if (e.shiftKey) toggleSelection(node.id);
          else if (!isSelected(node.id)) setSelectionSingle(node.id);
          else state.selection.nodeId = node.id;

          syncSelection();
          clearSnapLink();

          const op = getCurrentOp();
          if (!op) return;

          const bounds = getCanvasBounds();
          const canvasRect = dom.canvas.getBoundingClientRect();
          const startScreen = { x: e.clientX - canvasRect.left, y: e.clientY - canvasRect.top };
          const startWorld = screenToWorld(startScreen);

           const selectedIds = Array.from(ensureSelectionSet());
           const movingIds = selectedIds.length > 1 && isSelected(node.id) ? selectedIds : [node.id];
           const movingSet = new Set(movingIds);

          const startPositions = new Map();
          movingIds.forEach((id) => {
            const n = findNode(op, id);
            if (n) startPositions.set(id, { x: n.x, y: n.y });
          });

          const anchorStart = startPositions.get(node.id) || { x: node.x, y: node.y };
          const offset = { x: startWorld.x - anchorStart.x, y: startWorld.y - anchorStart.y };

          el.setPointerCapture?.(e.pointerId);

          let moved = false;
          let historySaved = false;

           const onMove = (ev) => {
            const curScreen = { x: ev.clientX - canvasRect.left, y: ev.clientY - canvasRect.top };
            const curWorld = screenToWorld(curScreen);
            const nextAnchor = { x: curWorld.x - offset.x, y: curWorld.y - offset.y };
            const dx = nextAnchor.x - anchorStart.x;
            const dy = nextAnchor.y - anchorStart.y;

            if (!moved && Math.hypot(dx, dy) > 2.5) {
              if (!historySaved) {
                saveHistory();
                historySaved = true;
              }
              moved = true;
            }

            startPositions.forEach((p, id) => {
              const n = findNode(op, id);
              if (!n) return;
              n.x = clamp(p.x + dx, bounds.minX, bounds.maxX);
              n.y = clamp(p.y + dy, bounds.minY, bounds.maxY);
              const elN = dom.nodeEls.get(id);
              if (elN) {
                elN.style.left = `${n.x}px`;
                elN.style.top = `${n.y}px`;
              }
            });

             updateSnapLinkDuringDrag(node.id, { excludeIds: movingSet });
             updateWires();
           };

           const onUp = () => {
             window.removeEventListener("pointermove", onMove);
             window.removeEventListener("pointerup", onUp);

             const snap = moved ? computeSnapCandidates(node.id, { excludeIds: movingSet }) : { inFromId: null, outToId: null };

             clearSnapLink();

             const hasSnap = !!(snap.inFromId || snap.outToId);
             if (hasSnap) {
              if (!historySaved) {
                saveHistory();
                historySaved = true;
              }

              const ensureEdge = (fromId, toId) => {
                const from = findNode(op, fromId);
                const to = findNode(op, toId);
                if (!from || !to) return;
                if (from.type === "end" || to.type === "start") return;
                const exists = op.edges.some((ed) => ed.from === fromId && ed.to === toId);
                if (!exists) op.edges.push({ id: uid("e"), from: fromId, to: toId });
              };

              if (snap.inFromId) ensureEdge(snap.inFromId, node.id);
              if (snap.outToId) ensureEdge(node.id, snap.outToId);
            }

             if (moved || hasSnap) persistSoon();
             updateWires();
           };

          window.addEventListener("pointermove", onMove);
          window.addEventListener("pointerup", onUp);
        });
      }

      function startConnect(fromNodeId) {
        state.connectMode.fromNodeId = fromNodeId;
        state.connectMode.pointer = null;
        updateWires();
      }

      function finishConnect(toNodeId) {
        const fromNodeId = state.connectMode.fromNodeId;
        if (!fromNodeId) return;
        const op = getCurrentOp();
        if (!op) return;
        const from = findNode(op, fromNodeId);
        const to = findNode(op, toNodeId);
        if (!from || !to) return;
        if (from.type === "end" || to.type === "start") return;
        const exists = op.edges.some((e) => e.from === fromNodeId && e.to === toNodeId);
        if (!exists) {
          saveHistory();
          op.edges.push({ id: uid("e"), from: fromNodeId, to: toNodeId });
        }
        cancelConnect();
        updateWires();
      }

      function cancelConnect() {
        state.connectMode.fromNodeId = null;
        state.connectMode.pointer = null;
        updateWires();
      }

      // connect preview follows pointer in canvas
      dom.canvas.addEventListener("pointermove", (e) => {
        if (!state.connectMode.fromNodeId) return;
        const r = dom.canvas.getBoundingClientRect();
        state.connectMode.pointer = { x: e.clientX - r.left, y: e.clientY - r.top };
        updateWires();
      });

      dom.canvas.addEventListener("click", (e) => {
        if (!state.connectMode.fromNodeId) return;
        if (!e.target.closest(".handle")) cancelConnect();
      });

      // ===== Modal editor =====
      let editing = { opId: null, nodeId: null };

      function openEditor(nodeId) {
        const op = getCurrentOp();
        const node = op ? findNode(op, nodeId) : null;
        if (!node) return;
        setSelectionSingle(node.id);
        syncSelection();
        editing = { opId: op.id, nodeId: node.id };
        byId("modalTitle").textContent = `Éditer : ${node.title}`;
        byId("fName").value = node.title;
        byId("fMode").value = node.data?.mode || "Automatic";
        byId("fDesc").value = node.data?.description || "";
        renderTypeFields(node);
        byId("modalBackdrop").classList.add("active");
        updateModalLock();
      }

      function closeEditor() {
        byId("modalBackdrop").classList.remove("active");
        editing = { opId: null, nodeId: null };
        updateModalLock();
      }

      function renderTypeFields(node) {
        const wrap = byId("typeFields");
        wrap.innerHTML = "";

        const hint = document.createElement("div");
        hint.className = "aiHint";
        hint.textContent = PDF_KB.phaseTypes[node.type] || "Configurer la phase.";
        wrap.appendChild(hint);

        if (node.type === "parameter") {
          const f = document.createElement("div");
          f.className = "field";
          f.innerHTML = `
            <label>Paramètres (ex: TEMP.Setpoint=37)</label>
            <div style="display:flex;gap:10px;align-items:center;">
              <input id="fParamAdd" placeholder="Ajouter un paramètre puis Entrée" />
              <button class="miniIcon" id="fPickVar" title="SELECT VARIABLE" aria-label="SELECT VARIABLE">
                <svg viewBox="0 0 24 24" fill="none"><path d="M4 7h16M4 12h10M4 17h16" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
              </button>
            </div>
          `;
          wrap.appendChild(f);

          const tagRow = document.createElement("div");
          tagRow.className = "tagRow";
          tagRow.id = "paramTags";
          wrap.appendChild(tagRow);

           node.data.parameters = node.data.parameters || [];
           renderTags("paramTags", node.data.parameters, (idx) => {
             saveHistory();
             node.data.parameters.splice(idx, 1);
             updateNodeSubFromData(node);
             renderCanvas();
             syncSelection();
             openEditor(node.id);
           });

          const input = f.querySelector("#fParamAdd");
          const pickBtn = f.querySelector("#fPickVar");
          pickBtn?.addEventListener("click", () => openVarPicker({ target: input, mode: "parameter", title: "SELECT VARIABLE" }));
          input.addEventListener("keydown", (e) => {
              if (e.key !== "Enter") return;
              const v = input.value.trim();
              if (!v) return;
              saveHistory();
              node.data.parameters.push(v);
              input.value = "";
              updateNodeSubFromData(node);
              renderCanvas();
              syncSelection();
              openEditor(node.id);
            });

          const details = document.createElement("details");
          details.className = "aiDetails";
          details.innerHTML = `<summary>Variables & templates <small>Setpoint / State / Mode</small></summary>`;
          wrap.appendChild(details);

          const vars = document.createElement("div");
          vars.className = "varChips";
          vars.setAttribute("aria-label", "Variables");
          details.appendChild(vars);

          const preset = document.createElement("div");
          preset.className = "varChip";
          preset.textContent = "Preset pO2 control (PDF)";
          preset.title = "Ajoute pO2.State=remote, pO2.Mode=auto, pO2.Setpoint=35";
          preset.addEventListener("click", () => {
            saveHistory();
            const list = node.data.parameters || [];
            ["pO2.State=remote", "pO2.Mode=auto", "pO2.Setpoint=35"].forEach((p) => {
              if (!list.includes(p)) list.push(p);
            });
            node.data.parameters = list;
            updateNodeSubFromData(node);
            renderCanvas();
            syncSelection();
            openEditor(node.id);
          });
          vars.appendChild(preset);

          const resetCalc = document.createElement("div");
          resetCalc.className = "varChip";
          resetCalc.textContent = "Reset calc O2_Totalizer (PDF)";
          resetCalc.title = "Ajoute RESET(O2_Totalizer.Value;0) (exemple PDF reset calculation)";
          resetCalc.addEventListener("click", () => {
            saveHistory();
            const list = node.data.parameters || [];
            const p = "RESET(O2_Totalizer.Value;0)";
            if (!list.includes(p)) list.unshift(p);
            node.data.parameters = list;
            updateNodeSubFromData(node);
            renderCanvas();
            syncSelection();
            openEditor(node.id);
           });
          vars.appendChild(resetCalc);

          variableCatalog
            .filter((v) => /(Setpoint|State|Mode)$/.test(v.token))
            .forEach((v) => {
              const chip = document.createElement("div");
              chip.className = "varChip muted";
              chip.textContent = v.label;
              chip.title = "Insérer dans le champ d’ajout";
              chip.addEventListener("click", () => {
                input.focus();
                lastTextTarget = input;
                insertAtCaret(input, `${v.token}=`);
              });
              vars.appendChild(chip);
            });
         }

        if (node.type === "wait") {
          const grid = document.createElement("div");
          grid.className = "stack";
          grid.innerHTML = `
            <div class="field"><label>Durée *</label><input id="fWaitDur" type="number" min="0" step="1" /></div>
            <div class="field"><label>Unité</label>
              <select id="fWaitUnit">
                <option value="s">seconds</option>
                <option value="min">minutes</option>
                <option value="h">hours</option>
                <option value="d">days</option>
              </select>
            </div>
          `;
          wrap.appendChild(grid);
          grid.querySelector("#fWaitDur").value = node.data.duration ?? 1;
          grid.querySelector("#fWaitUnit").value = node.data.unit ?? "min";
        }

        if (node.type === "operator") {
          const f = document.createElement("div");
          f.className = "field";
          f.innerHTML = `<label>Décisions (max 3)</label><input id="fDecisionAdd" placeholder="Ajouter une décision puis Entrée" />`;
          wrap.appendChild(f);

          const tagRow = document.createElement("div");
          tagRow.className = "tagRow";
          tagRow.id = "decisionTags";
          wrap.appendChild(tagRow);

           node.data.decisions = node.data.decisions || [];
           renderTags("decisionTags", node.data.decisions, (idx) => {
             saveHistory();
             node.data.decisions.splice(idx, 1);
             openEditor(node.id);
           });

          const note = document.createElement("div");
          note.className = "field";
          note.innerHTML = `<label>Notification</label><textarea id="fOpMsg" placeholder="Message pour l’opérateur"></textarea>`;
          wrap.appendChild(note);
          note.querySelector("#fOpMsg").value = node.data.message || "";

          const input = f.querySelector("#fDecisionAdd");
          input.addEventListener("keydown", (e) => {
            if (e.key !== "Enter") return;
             const v = input.value.trim();
             if (!v) return;
             if (node.data.decisions.length >= 3) return;
             saveHistory();
             node.data.decisions.push(v);
             input.value = "";
             openEditor(node.id);
           });
         }

        if (node.type === "instrument") {
          const s = document.createElement("div");
          s.className = "stack";
          s.innerHTML = `
            <div class="field">
              <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
                <label>Phase *</label>
                <button class="miniIcon" id="fPickPhase" title="SELECT PHASE" aria-label="SELECT PHASE">
                  <svg viewBox="0 0 24 24" fill="none"><path d="M4 7h16M4 12h10M4 17h16" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
                </button>
              </div>
              <input id="fInstrPhase" placeholder="ex: pO2" />
            </div>
            <div class="field"><label>Force restart</label>
              <select id="fInstrRestart">
                <option value="No">No</option>
                <option value="Yes">Yes</option>
              </select>
            </div>
          `;
          wrap.appendChild(s);
          const phaseInput = s.querySelector("#fInstrPhase");
          phaseInput.value = node.data.phase || "";
          s.querySelector("#fInstrRestart").value = node.data.forceRestart || "No";
          s.querySelector("#fPickPhase")?.addEventListener("click", () =>
            openPhasePicker({ target: phaseInput, title: "SELECT PHASE" }),
          );
        }

        if (node.type === "profile") {
          const f = document.createElement("div");
          f.className = "stack";
          f.innerHTML = `
            <div class="field"><label>Variable</label><input id="fProfVar" placeholder="ex: TEMP.Setpoint" /></div>
            <div class="field"><label>Interpolation</label>
              <select id="fProfInterp">
                <option value="Linear">Linear</option>
                <option value="Step">Step</option>
              </select>
            </div>
            <div class="field"><label>Unité temps</label>
              <select id="fProfUnit">
                <option value="min">minutes</option>
                <option value="h">hours</option>
              </select>
            </div>
            <div class="field"><label>Points (t,val)</label><textarea id="fProfPoints" placeholder="0,0\\n30,100"></textarea></div>
          `;
          wrap.appendChild(f);
          f.querySelector("#fProfVar").value = node.data.variable || "";
          f.querySelector("#fProfInterp").value = node.data.interpolation || "Linear";
          f.querySelector("#fProfUnit").value = node.data.unit || "min";
          const pts = (node.data.points || []).map((p) => `${p.t},${p.v}`).join("\n");
          f.querySelector("#fProfPoints").value = pts || "0,0\n30,100";
        }

        if (node.type === "calc") {
          const f = document.createElement("div");
          f.className = "stack";
          f.innerHTML = `
            <div class="field">
              <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
                <label>Target variable</label>
                <button class="miniIcon" id="fPickCalc" title="SELECT CALCULATION" aria-label="SELECT CALCULATION">
                  <svg viewBox="0 0 24 24" fill="none"><path d="M4 7h16M4 12h10M4 17h16" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
                </button>
              </div>
              <input id="fCalcTarget" placeholder="ex: OUR_value" />
            </div>
            <div class="field">
              <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
                <label>Formule</label>
                <button class="miniIcon" id="openCalcFx" title="Éditer la formule (ƒx)" aria-label="Éditer la formule (ƒx)">
                  <svg viewBox="0 0 24 24" fill="none"><path d="M7 17 17 7M9 7h6M7 9v6M17 15v2" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
                </button>
              </div>
              <textarea id="fCalcFormula" placeholder="Ex: Totalizer_O2 = getValue(O2_Totalizer.Value;0) + O2_Flow.Value × (calcCycle() / 60)"></textarea>
              <div class="varChips" id="calcVars"></div>
            </div>
            <div class="field"><label>Unité (optionnel)</label><input id="fCalcUnit" placeholder="ex: mmol/L/h" /></div>
            <div class="aiHint" id="fCalcPreview"></div>
          `;
          wrap.appendChild(f);

          const target = f.querySelector("#fCalcTarget");
          const formula = f.querySelector("#fCalcFormula");
          const unit = f.querySelector("#fCalcUnit");
          const vars = f.querySelector("#calcVars");
          const openFx = f.querySelector("#openCalcFx");
          const pickCalc = f.querySelector("#fPickCalc");

          target.value = node.data.target || "";
          formula.value = node.data.formula || "";
          unit.value = node.data.unit || "";

          pickCalc?.addEventListener("click", () =>
            openCalcPicker({ target, title: "SELECT CALCULATION", mode: "replace" }),
          );

          variableCatalog
            .filter((v) => v.sensor)
            .forEach((v) => {
              const chip = document.createElement("div");
              chip.className = "varChip";
              chip.textContent = v.label;
              chip.addEventListener("click", () => {
                formula.focus();
                lastTextTarget = formula;
                pickVariable(v.token);
              });
              vars.appendChild(chip);
            });

          // MFCS-like helpers
          ["getValue(", "calcCycle()", "×", "(", ")", "+", "-", "/"].forEach((tok) => {
            const chip = document.createElement("div");
            chip.className = "varChip muted";
            chip.textContent = tok;
            chip.title = "Insérer";
            chip.addEventListener("click", () => {
              formula.focus();
              lastTextTarget = formula;
              insertAtCaret(formula, tok);
            });
            vars.appendChild(chip);
          });

          openFx?.addEventListener("click", () => {
            openFormulaEditor({
              kind: "calc",
              title: "Formula editor",
              value: formula.value,
              onCommit: (next) => {
                formula.value = String(next || "");
                formula.dispatchEvent(new Event("input", { bubbles: true }));
              },
            });
          });

          formula.addEventListener("input", refreshCalcPreviewIfOpen);
          unit.addEventListener("input", refreshCalcPreviewIfOpen);
          refreshCalcPreviewIfOpen();
        }

        renderTransitionsEditor(wrap, node);
      }

      function renderTransitionsEditor(wrap, node) {
        const op = getCurrentOp();
        if (!op) return;
        const outgoing = op.edges.filter((e) => e.from === node.id);
        if (!outgoing.length) return;

        const header = document.createElement("div");
        header.className = "aiHint";
        header.style.marginTop = "8px";
        header.textContent = "Transitions sortantes (condition optionnelle)";
        wrap.appendChild(header);

        outgoing.forEach((edge) => {
          const to = findNode(op, edge.to);
          const field = document.createElement("div");
          field.className = "field";
          field.innerHTML = `
            <label>Vers : ${escapeHtml(to ? to.title : edge.to)}</label>
            <div style="display:flex;gap:10px;align-items:center;">
              <input value="${escapeHtml(edge.condition || "")}" placeholder="ex: pO2.Value < 35%" />
              <button class="miniIcon" title="Éditer la condition (ƒx)" aria-label="Éditer la condition (ƒx)">
                <svg viewBox="0 0 24 24" fill="none"><path d="M7 17 17 7M9 7h6M7 9v6M17 15v2" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
              </button>
              <button class="miniIcon" title="Supprimer la transition" aria-label="Supprimer la transition">
                <svg viewBox="0 0 24 24" fill="none"><path d="M6 7h12M10 7V5h4v2m-7 0 1 14h8l1-14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
              </button>
            </div>
          `;
          const input = field.querySelector("input");
          const btns = field.querySelectorAll("button");
          const edit = btns[0];
          const del = btns[1];
          let conditionSnap = false;
          input.addEventListener("focus", () => {
            lastTextTarget = input;
          });
          input.addEventListener("input", () => {
            if (!conditionSnap) {
              saveHistory();
              conditionSnap = true;
            }
            edge.condition = input.value.trim() || undefined;
            updateWires();
            persistSoon();
          });
          input.addEventListener("blur", () => {
            conditionSnap = false;
          });
          del.addEventListener("click", () => {
            saveHistory();
            op.edges = op.edges.filter((e) => e.id !== edge.id);
            renderCanvas();
            syncSelection();
            openEditor(node.id);
          });

          edit.addEventListener("click", () => {
            openFormulaEditor({
              kind: "condition",
              title: "EDIT CONDITION",
              value: input.value,
              onCommit: (next) => {
                input.value = String(next || "");
                input.dispatchEvent(new Event("input", { bubbles: true }));
              },
            });
          });

          const chips = document.createElement("div");
          chips.className = "varChips";
          ["pO2.Value", "pH.Value", "TEMP.Value", "OD.Value", "<", ">", "<=", ">=", "=="].forEach((tok) => {
            const chip = document.createElement("div");
            chip.className = "varChip muted";
            chip.textContent = tok;
            chip.title = "Insérer dans la condition";
            chip.addEventListener("click", () => {
              input.focus();
              lastTextTarget = input;
              insertAtCaret(input, tok.includes(".") ? tok : ` ${tok} `);
            });
            chips.appendChild(chip);
          });
          field.appendChild(chips);
          wrap.appendChild(field);
        });
      }

      function renderTags(containerId, tags, onRemove) {
        const container = byId(containerId);
        container.innerHTML = "";
        tags.forEach((t, idx) => {
          const tag = document.createElement("div");
          tag.className = "tag";
          tag.innerHTML = `<span>${escapeHtml(t)}</span><button title="Retirer">×</button>`;
          tag.querySelector("button").addEventListener("click", () => onRemove(idx));
          container.appendChild(tag);
        });
      }

      function updateNodeSubFromData(node) {
        if (node.type === "parameter") {
          const params = Array.isArray(node.data?.parameters) ? node.data.parameters : [];
          const parts = [];
          for (const p of params) {
            const raw = String(p || "").trim();
            if (!raw) continue;

            const m = raw.match(/^RESET\s*\(\s*([^;,)]+?)\s*[;,]\s*([^)]+?)\s*\)$/i);
            if (m) {
              const tok = normalizeDotSpacing(m[1].trim());
              const val = m[2].trim();
              parts.push(`Reset ${tok} → ${val}`);
            } else if (raw.includes("=")) {
              const idx = raw.indexOf("=");
              const key = normalizeDotSpacing(raw.slice(0, idx).trim());
              const val = raw.slice(idx + 1).trim();
              parts.push(val ? `${key} ${val}` : key);
            } else {
              parts.push(raw);
            }

            if (parts.length >= 3) break;
          }
          node.sub = parts.join(" · ");
        }
        if (node.type === "wait") {
          const d = node.data?.duration;
          const u = node.data?.unit;
          if (d != null && u) node.sub = `Durée ${d} ${u}`;
        }
        if (node.type === "instrument") {
          const ph = node.data?.phase || "";
          node.sub = ph ? `Phase ${ph}` : "";
        }
        if (node.type === "profile") {
          const v = node.data?.variable || "";
          node.sub = v ? `Profil ${v}` : "";
        }
        if (node.type === "calc") {
          const target = node.data?.target || "";
          const unit = node.data?.unit ? ` ${node.data.unit}` : "";
          const formula = node.data?.formula || "";
          if (target && formula) node.sub = `${target} = ${formula}${unit}`.slice(0, 46);
          else if (formula) node.sub = `ƒx ${formula}`.slice(0, 46);
          else node.sub = "";
        }
      }

      function saveEditor() {
        const op = getOp(editing.opId);
        if (!op) return;
        const node = findNode(op, editing.nodeId);
        if (!node) return;

        saveHistory();
        node.title = byId("fName").value.trim() || node.title;
        node.data = node.data || {};
        node.data.mode = byId("fMode").value;
        node.data.description = byId("fDesc").value.trim();

        const wrap = byId("typeFields");
        if (node.type === "wait") {
          node.data.duration = Number(wrap.querySelector("#fWaitDur")?.value || 1);
          node.data.unit = wrap.querySelector("#fWaitUnit")?.value || "min";
          updateNodeSubFromData(node);
        }
        if (node.type === "operator") {
          node.data.message = wrap.querySelector("#fOpMsg")?.value?.trim() || "";
        }
        if (node.type === "instrument") {
          node.data.phase = wrap.querySelector("#fInstrPhase")?.value?.trim() || "";
          node.data.forceRestart = wrap.querySelector("#fInstrRestart")?.value || "No";
          updateNodeSubFromData(node);
        }
        if (node.type === "profile") {
          node.data.variable = wrap.querySelector("#fProfVar")?.value?.trim() || "";
          node.data.interpolation = wrap.querySelector("#fProfInterp")?.value || "Linear";
          node.data.unit = wrap.querySelector("#fProfUnit")?.value || "min";
          const raw = wrap.querySelector("#fProfPoints")?.value || "";
          node.data.points = raw
            .split(/\r?\n/)
            .map((line) => line.trim())
            .filter(Boolean)
            .map((line) => {
              const [t, v] = line.split(",").map((s) => s.trim());
              return { t: Number(t), v: Number(v) };
            })
            .filter((p) => Number.isFinite(p.t) && Number.isFinite(p.v));
          updateNodeSubFromData(node);
        }
        if (node.type === "calc") {
          node.data.target = wrap.querySelector("#fCalcTarget")?.value?.trim() || "";
          node.data.formula = wrap.querySelector("#fCalcFormula")?.value?.trim() || "";
          node.data.unit = wrap.querySelector("#fCalcUnit")?.value?.trim() || "";
          updateNodeSubFromData(node);
        }
        if (node.type === "parameter") updateNodeSubFromData(node);

        renderCanvas();
        syncSelection();
        closeEditor();
      }

      function deleteEditingNode() {
        const op = getOp(editing.opId);
        if (!op) return;
        const idx = op.nodes.findIndex((n) => n.id === editing.nodeId);
        if (idx < 0) return;
        saveHistory();
        op.nodes.splice(idx, 1);
        op.edges = op.edges.filter((e) => e.from !== editing.nodeId && e.to !== editing.nodeId);
        if (isSelected(editing.nodeId)) {
          ensureSelectionSet().delete(editing.nodeId);
          if (state.selection.nodeId === editing.nodeId) state.selection.nodeId = ensureSelectionSet().values().next().value || null;
        }
        renderCanvas();
        syncSelection();
        closeEditor();
      }

      function deleteSelectedNodes() {
        const op = getCurrentOp();
        const ids = Array.from(ensureSelectionSet());
        if (!op || !ids.length) return;
        const del = new Set(ids);
        saveHistory();
        op.nodes = op.nodes.filter((n) => !del.has(n.id));
        op.edges = op.edges.filter((e) => !del.has(e.from) && !del.has(e.to));
        clearSelection();
        renderCanvas();
        syncSelection();
        persistSoon();
      }

      // ===== Preview / simulation =====
      function orderedNodes(op) {
        const outgoing = new Map();
        op.edges.forEach((e) => {
          if (!outgoing.has(e.from)) outgoing.set(e.from, []);
          outgoing.get(e.from).push(e.to);
        });
        const start = op.nodes.find((n) => n.type === "start")?.id || op.nodes[0]?.id;
        const visited = new Set();
        const order = [];
        const dfs = (id) => {
          if (!id || visited.has(id)) return;
          visited.add(id);
          order.push(id);
          (outgoing.get(id) || []).forEach(dfs);
        };
        dfs(start);
        op.nodes.forEach((n) => dfs(n.id));
        return order;
      }

      function delay(ms) {
        return new Promise((r) => setTimeout(r, ms));
      }

      function applyParameterResets(node) {
        if (!node || node.type !== "parameter") return;
        const list = Array.isArray(node.data?.parameters) ? node.data.parameters : [];
        list.forEach((p) => {
          const raw = String(p || "").trim();
          const m = raw.match(/^RESET\s*\(\s*([^;,)]+?)\s*[;,]\s*([^)]+?)\s*\)$/i);
          if (!m) return;
          const tok = normalizeDotSpacing(m[1].trim());
          const val = Number(String(m[2] || "").replaceAll(",", ".").trim());
          if (!Number.isFinite(val)) return;
          const entry = variableCatalog.find((v) => v.token === tok);
          const key = entry?.sensor;
          if (!key || !sensors[key]) return;
          sensors[key].value = val;
        });
      }

      async function simulateOperation() {
        const op = getCurrentOp();
        if (!op || !op.nodes.length) return;
        const order = orderedNodes(op);
        for (const nodeId of order) {
          const node = findNode(op, nodeId);
          applyParameterResets(node);
          setSelectionSingle(nodeId);
          syncSelection();
          await delay(450);
        }
        clearSelection();
        syncSelection();
      }

      // ===== AI (démo locale) =====
      function toggleAI(open) {
        byId("aiDrawer").classList.toggle("active", !!open);
        if (open) setAiMode(uiPrefs.aiMode || "chat", { persist: false });
      }

      function setAiMode(mode, { persist } = {}) {
        const next = ["chat", "actions", "demos", "tools"].includes(mode) ? mode : "chat";
        uiPrefs.aiMode = next;
        if (persist !== false) savePrefs();

        document.querySelectorAll(".aiModeBtn").forEach((btn) => {
          const active = btn.dataset.aiMode === next;
          btn.classList.toggle("active", active);
          btn.setAttribute("aria-selected", active ? "true" : "false");
        });
        document.querySelectorAll(".aiView").forEach((view) => {
          view.classList.toggle("active", view.dataset.aiView === next);
        });
      }

      function aiSetStatus(text) {
        const el = byId("aiStatus");
        if (!el) return;
        el.textContent = text || "";
      }

      function aiSetOutput(text) {
        const out = byId("aiOut");
        if (!out) return;
        out.textContent = text || "";
        out.scrollTop = out.scrollHeight;
      }

      function aiAppendOutput(line) {
        const out = byId("aiOut");
        if (!out) return;
        const current = out.textContent || "";
        out.textContent = current ? `${current}\n${line}` : line;
        out.scrollTop = out.scrollHeight;
      }

      function aiUpdateApplyButton() {
        const btn = byId("applyAI");
        if (!btn) return;
        const count = Array.isArray(state.ai.lastActions) ? state.ai.lastActions.length : 0;
        btn.textContent = count ? `Appliquer (${count})` : "Appliquer";
        btn.disabled = state.ai.running || count === 0;
      }

      function renderAiVars() {
        const el = byId("aiVars");
        if (!el) return;
        el.innerHTML = "";
        variableCatalog
          .filter((v) => v.sensor)
          .forEach((v) => {
            const chip = document.createElement("div");
            chip.className = "varChip";
            chip.textContent = v.label;
            chip.title = "Insérer (si un champ est sélectionné) ou copier";
            chip.addEventListener("mousedown", (e) => {
              e.preventDefault();
              pickVariable(v.token);
            });
            el.appendChild(chip);
          });
      }

      function renderAiPlanList(actions) {
        const wrap = byId("aiPlanWrap");
        const list = byId("aiPlan");
        if (!wrap || !list) return;

        if (!Array.isArray(actions) || actions.length === 0) {
          wrap.style.display = "none";
          list.innerHTML = "";
          return;
        }

        wrap.style.display = "flex";
        list.innerHTML = "";
        actions.forEach((step, idx) => {
          const row = document.createElement("div");
          row.className = "aiPlanItem";
          row.dataset.index = String(idx);
          const title = step?.note || step?.text || step?.type || `Étape ${idx + 1}`;
          const meta = [step?.type, step?.opId ? `op:${step.opId}` : ""].filter(Boolean).join(" • ");
          row.innerHTML = `
            <div class="aiPlanNum">${idx + 1}</div>
            <div style="min-width:0;">
              <div style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${escapeHtml(title)}</div>
              <div class="aiPlanMeta">${escapeHtml(meta)}</div>
            </div>
            <button class="miniIcon" title="Appliquer à partir d’ici" aria-label="Appliquer à partir d’ici">
              <svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l12-7-12-7Z"/></svg>
            </button>
          `;
          const btn = row.querySelector("button");
          btn.addEventListener("click", () => {
            const base = Array.isArray(state.ai.lastActions) ? state.ai.lastActions : actions;
            const slice = base.slice(idx);
            runAiActions(slice, { label: `Plan (depuis ${idx + 1})`, originIndex: idx });
          });
          row.addEventListener("click", (e) => {
            if (e.target.closest("button")) return;
            btn.click();
          });
          list.appendChild(row);
        });
      }

      function setAiPlanActiveIndex(index) {
        const list = byId("aiPlan");
        if (!list) return;
        list.querySelectorAll(".aiPlanItem").forEach((row) => {
          const idx = Number(row.dataset.index);
          row.classList.toggle("active", Number.isFinite(index) && idx === index);
          if (Number.isFinite(index) && idx === index) row.scrollIntoView({ block: "nearest" });
        });
      }

      function clearAiPlan() {
        state.ai.lastActions = null;
        aiSetStatus("");
        aiUpdateApplyButton();
        renderAiPlanList(null);
        setAiPlanActiveIndex(null);
      }

      function aiSetControlsDisabled(disabled) {
        document.querySelectorAll(".aiAction").forEach((btn) => {
          btn.disabled = !!disabled;
        });
        const q = byId("aiQ");
        if (q) q.disabled = !!disabled;
        const ask = byId("aiAskBtn");
        if (ask) ask.disabled = !!disabled;
        const copy = byId("copyAI");
        if (copy) copy.disabled = !!disabled;
        const auto = byId("aiAutoApply");
        if (auto) auto.disabled = !!disabled;
        aiUpdateApplyButton();
      }

      function flashNode(nodeId) {
        const el = dom.nodeEls.get(nodeId);
        if (!el) return;
        el.classList.remove("aiFlash");
        void el.offsetWidth;
        el.classList.add("aiFlash");
        setTimeout(() => el.classList.remove("aiFlash"), 950);
      }

      function ensureAiCursor() {
        if (dom.aiCursor && dom.aiCursor.isConnected) return dom.aiCursor;
        const el = document.createElement("div");
        el.className = "aiCursor";
        dom.canvas.appendChild(el);
        dom.aiCursor = el;
        return el;
      }

      function aiCursorActive(active) {
        const el = ensureAiCursor();
        el.classList.toggle("active", !!active);
      }

      function aiMoveCursorToNode(nodeId) {
        const cursor = ensureAiCursor();
        const nodeEl = dom.nodeEls.get(nodeId);
        if (!cursor || !nodeEl) return;
        const cr = dom.canvas.getBoundingClientRect();
        const nr = nodeEl.getBoundingClientRect();
        const x = nr.left - cr.left + nr.width / 2;
        const y = nr.top - cr.top + nr.height / 2;
        cursor.style.transform = `translate(${x}px, ${y}px) translate(-50%, -50%)`;
      }

      function aiSetPlan(plan) {
        const text = plan?.text || "";
        const actions = Array.isArray(plan?.actions) && plan.actions.length ? plan.actions : null;
        state.ai.lastText = text;
        state.ai.lastActions = actions;

        setAiMode("chat", { persist: false });
        aiSetOutput(text);
        aiSetStatus(actions ? `Plan prêt : ${actions.length} action(s). Clique “Appliquer”.` : "");
        aiUpdateApplyButton();
        renderAiPlanList(actions);
        setAiPlanActiveIndex(null);

        if (actions && byId("aiAutoApply")?.checked) runAiActions(actions, { label: "Auto" });
      }

      function aiPlanFromOperations(operations, title) {
        const ops = Array.isArray(operations) ? operations : [];
        if (!ops.length) return { text: title || "Aucune opération à appliquer.", actions: null };

        const actions = [];
        ops.forEach((op, idx) => {
          actions.push({ type: "ensureOp", opId: op.id, name: op.name, note: `Préparer : ${op.name}` });
          actions.push({ type: "selectOp", opId: op.id, note: `Ouvrir : ${op.name}` });
          actions.push({ type: "clearOp", opId: op.id, note: "Vider l’opération" });
          (op.nodes || []).forEach((n) => {
            actions.push({
              type: "createNode",
              opId: op.id,
              nodeId: n.id,
              node: deepClone(n),
              select: true,
              note: `Créer : ${n.title}`,
            });
          });
          (op.edges || []).forEach((e) => {
            actions.push({
              type: "connect",
              opId: op.id,
              fromId: e.from,
              toId: e.to,
              condition: e.condition,
              note: e.condition ? `Relier + condition (${e.condition})` : "Relier",
            });
          });
          if (idx < ops.length - 1) actions.push({ type: "wait", ms: 200 });
        });
        actions.push({ type: "selectOp", opId: ops[0].id, note: "Retour" });

        return { text: title || "Plan prêt.", actions };
      }

      function aiReserveNodeId(reserved, preferredId) {
        const preferred = preferredId || uid("ai");
        if (!reserved.has(preferred)) {
          reserved.add(preferred);
          return preferred;
        }
        let id = uid("ai");
        while (reserved.has(id)) id = uid("ai");
        reserved.add(id);
        return id;
      }

      function aiBuildMergeOpActions(opId, templateOp, { notePrefix } = {}) {
        const op = getOp(opId);
        if (!op || !templateOp) return null;

        const titleById = new Map((templateOp.nodes || []).map((n) => [n.id, n.title]));
        const actions = [
          { type: "ensureOp", opId, name: templateOp.name, note: `Préparer : ${templateOp.name}` },
          { type: "selectOp", opId, note: `Ouvrir : ${templateOp.name}` },
        ];

        const reserved = new Set((op.nodes || []).map((n) => n.id));
        const idMap = new Map();

        (templateOp.nodes || []).forEach((t) => {
          const existing = op.nodes.find((n) => n.type === t.type);
          if (existing) {
            idMap.set(t.id, existing.id);
            actions.push({
              type: "updateNode",
              opId,
              nodeId: existing.id,
              select: true,
              autoSub: true,
              patch: { title: t.title, sub: t.sub, data: deepClone(t.data || {}), x: t.x, y: t.y },
              note: `${notePrefix || "Mettre à jour"} : ${t.title}`,
            });
            return;
          }

          const nodeId = aiReserveNodeId(reserved, t.id);
          idMap.set(t.id, nodeId);
          const node = deepClone(t);
          node.id = nodeId;
          actions.push({
            type: "createNode",
            opId,
            nodeId,
            node,
            select: true,
            note: `${notePrefix || "Ajouter"} : ${t.title}`,
          });
        });

        (templateOp.edges || []).forEach((e) => {
          const fromId = idMap.get(e.from);
          const toId = idMap.get(e.to);
          if (!fromId || !toId) return;
          const labelA = titleById.get(e.from) || "phase";
          const labelB = titleById.get(e.to) || "phase";
          actions.push({
            type: "upsertEdge",
            opId,
            fromId,
            toId,
            condition: e.condition,
            note: e.condition ? `Condition (${e.condition}) : ${labelA} → ${labelB}` : `Relier : ${labelA} → ${labelB}`,
          });
        });

        return actions;
      }

      function aiBuildCompleteCurrentOpPlan(prompt = "") {
        const op = getCurrentOp();
        if (!op) return { text: "Aucune opération active.", actions: null };
        const kind = String(op.id || "").toLowerCase();
        const fallbackKind =
          kind === "prep" || kind === "inoc" || kind === "batch"
            ? kind
            : String(op.name || "").toLowerCase().includes("batch")
              ? "batch"
              : String(op.name || "").toLowerCase().includes("inoc")
                ? "inoc"
                : String(op.name || "").toLowerCase().includes("prep")
                  ? "prep"
                  : null;

        const built = buildGeneratedOperationsFromPrompt(prompt || "");
        const templateOp =
          built.operations.find((o) => o.id === fallbackKind) || PDF_KB.exampleRecipe.operations.find((o) => o.id === fallbackKind) || null;
        if (!templateOp) {
          return {
            text: "Je peux compléter automatiquement les opérations Preparation/Inoculation/Batch (PDF).",
            actions: [{ type: "fixCurrentOp", opId: op.id, note: "Compléter l’opération courante" }],
          };
        }

        const actions = aiBuildMergeOpActions(op.id, templateOp, { notePrefix: "IA" });
        return {
          text: `Plan IA — Compléter "${op.name}" (${templateOp.name})`,
          actions,
        };
      }

      function aiBuildPo2ConditionsPlan(prompt = "") {
        const current = getCurrentOp();
        const isBatch =
          String(current?.id || "").toLowerCase() === "batch" || String(current?.name || "").toLowerCase().includes("batch");
        const opId = isBatch ? current.id : getOp("batch") ? "batch" : current?.id;
        const op = opId ? getOp(opId) : null;
        if (!op) return { text: "Aucune opération Batch trouvée.", actions: null };

        const built = buildGeneratedOperationsFromPrompt(prompt || "");
        const templateOp = built.operations.find((o) => o.id === "batch") || PDF_KB.exampleRecipe.operations.find((o) => o.id === "batch");
        const actions = aiBuildMergeOpActions(opId, templateOp, { notePrefix: "IA" });
        return {
          text: `Plan IA — Conditions pO2 sur "${op.name}"`,
          actions,
        };
      }

      async function runAiActions(actions, { label, originIndex } = {}) {
        if (!Array.isArray(actions) || actions.length === 0) return;
        if (state.ai.running) return;

        const baseIndex = Number.isFinite(originIndex) ? originIndex : 0;
        state.ai.running = true;
        setAiMode("chat", { persist: false });
        aiSetControlsDisabled(true);
        aiSetStatus(label ? `Exécution IA : ${label}` : "Exécution IA…");
        aiUpdateApplyButton();
        aiCursorActive(true);

        // One undo snapshot for the whole run
        state.history.push(snapshot());
        if (state.history.length > 80) state.history.shift();
        state.future = [];

        try {
          const total = actions.length;
          let i = 0;
          for (const step of actions) {
            i += 1;
            aiSetStatus(label ? `Exécution IA : ${label} (${i}/${total})` : `Exécution IA… (${i}/${total})`);
            setAiPlanActiveIndex(baseIndex + i - 1);
            await aiApplyStep(step);
          }
          aiSetStatus("Terminé.");
          persistSoon?.();
        } catch (e) {
          aiAppendOutput(`\n[Erreur] ${e?.message || String(e)}`);
          aiSetStatus("Erreur pendant l’exécution.");
        } finally {
          state.ai.running = false;
          aiSetControlsDisabled(false);
          aiUpdateApplyButton();
          aiCursorActive(false);
          setAiPlanActiveIndex(null);
        }
      }

      async function aiApplyStep(step) {
        const type = step?.type;
        if (!type) return;

        if (type === "wait") {
          await delay(aiMs(step.ms ?? 220));
          return;
        }
        if (type === "note") {
          if (step.text) aiAppendOutput(`• ${step.text}`);
          return;
        }

        if (type === "layout") {
          const dir = step.direction === "v" ? "v" : "h";
          autoLayoutCurrentOp(dir);
          if (step.note) aiAppendOutput(`✓ ${step.note}`);
          await delay(aiMs(step.ms ?? 180));
          return;
        }

        if (type === "selectOp") {
          state.currentOpId = step.opId || state.currentOpId;
          clearSelection();
          cancelConnect();
          renderOperations();
          renderWorkspaceHeader();
          renderCanvas();
          syncSelection();
          if (step.note) aiAppendOutput(`✓ ${step.note}`);
          await delay(aiMs(step.ms ?? 160));
          return;
        }

        if (type === "ensureOp") {
          const opId = step.opId;
          if (!opId) return;
          const name = step.name || "Operation";
          let op = getOp(opId);
          const created = !op;
          if (!op) {
            op = { id: opId, name, nodes: [], edges: [] };
            state.operations.push(op);
          } else if (name && op.name !== name) {
            op.name = name;
          }
          if (created || step.name) {
            renderOperations();
            renderWorkspaceHeader();
          }
          if (step.note) aiAppendOutput(`✓ ${step.note}`);
          await delay(aiMs(step.ms ?? 120));
          return;
        }

        const opId = step.opId || state.currentOpId;
        const op = getOp(opId);
        if (!op) return;

        if (type === "clearOp") {
          op.nodes = [];
          op.edges = [];
          if (opId === state.currentOpId) {
            clearSelection();
            cancelConnect();
            renderCanvas();
            syncSelection();
          }
          if (step.note) aiAppendOutput(`✓ ${step.note}`);
          await delay(aiMs(step.ms ?? 160));
          return;
        }

        if (type === "createNode") {
          const nodeRaw = step.node || {};
          const nodeId = step.nodeId && !findNode(op, step.nodeId) ? step.nodeId : uid("node");
          const rect = dom.canvas.getBoundingClientRect();
          const bounds = getCanvasBounds();
          const base = screenToWorld({ x: rect.width * 0.35, y: rect.height * 0.35 });
          let baseX = base.x;
          let baseY = base.y;
          if (nodeRaw.x == null && nodeRaw.y == null) {
            const anchorId = step.nearId || (opId === state.currentOpId ? state.selection.nodeId : null);
            const anchor = anchorId ? findNode(op, anchorId) : null;
            if (anchor) {
              baseX = (anchor.x ?? baseX) + 240;
              baseY = anchor.y ?? baseY;
            } else if (op.nodes.length) {
              const maxX = op.nodes.reduce((m, n) => Math.max(m, n.x ?? 0), 320);
              baseX = maxX + 240;
              baseY = op.nodes[0]?.y ?? baseY;
            }
          }
          const pos = {
            x: clamp(nodeRaw.x ?? baseX, bounds.minX, bounds.maxX),
            y: clamp(nodeRaw.y ?? baseY, bounds.minY, bounds.maxY),
          };
          const node = {
            id: nodeId,
            type: nodeRaw.type || "parameter",
            title: nodeRaw.title || "Node",
            sub: nodeRaw.sub || "",
            x: pos.x,
            y: pos.y,
            data: deepClone(nodeRaw.data || defaultDataForType(nodeRaw.type || "parameter")),
          };
          op.nodes.push(node);
          if (opId === state.currentOpId) {
            if (step.select) setSelectionSingle(nodeId);
            renderCanvas();
            syncSelection();
            aiMoveCursorToNode(nodeId);
            flashNode(nodeId);
          }
          if (step.note) aiAppendOutput(`✓ ${step.note}`);
          await delay(aiMs(step.ms ?? 180));
          return;
        }

        if (type === "updateNode") {
          const nodeId = step.nodeId;
          if (!nodeId) return;
          const node = findNode(op, nodeId);
          if (!node) return;
          const patch = step.patch || {};
          if (patch.type) node.type = patch.type;
          if (patch.title != null) node.title = patch.title;
          if (patch.sub != null) node.sub = patch.sub;
          if (patch.data) {
            node.data = step.mergeData ? { ...(node.data || {}), ...deepClone(patch.data) } : deepClone(patch.data);
          }
          if ((patch.x != null || patch.y != null) && dom.canvas) {
            const rect = dom.canvas.getBoundingClientRect();
            const bounds = getCanvasBounds(rect);
            if (patch.x != null) node.x = clamp(patch.x, bounds.minX, bounds.maxX);
            if (patch.y != null) node.y = clamp(patch.y, bounds.minY, bounds.maxY);
          }
          if (step.autoSub && patch.sub == null && patch.data && typeof updateNodeSubFromData === "function") {
            updateNodeSubFromData(node);
          }
          if (opId === state.currentOpId) {
            if (step.select) setSelectionSingle(nodeId);
            renderCanvas();
            syncSelection();
            aiMoveCursorToNode(nodeId);
            flashNode(nodeId);
          }
          if (step.note) aiAppendOutput(`✓ ${step.note}`);
          await delay(aiMs(step.ms ?? 180));
          return;
        }

        if (type === "connect") {
          const fromId = step.fromId;
          const toId = step.toId;
          if (!fromId || !toId) return;
          const exists = op.edges.some((e) => e.from === fromId && e.to === toId && (e.condition || "") === (step.condition || ""));
          if (!exists) op.edges.push({ id: uid("e"), from: fromId, to: toId, condition: step.condition });
          if (opId === state.currentOpId) {
            renderCanvas();
            syncSelection();
            aiMoveCursorToNode(fromId);
            flashNode(fromId);
            await delay(aiMs(90));
            aiMoveCursorToNode(toId);
            flashNode(toId);
          }
          if (step.note) aiAppendOutput(`✓ ${step.note}`);
          await delay(aiMs(step.ms ?? 180));
          return;
        }

        if (type === "upsertEdge") {
          const fromId = step.fromId;
          const toId = step.toId;
          if (!fromId || !toId) return;
          let edge = op.edges.find((e) => e.from === fromId && e.to === toId);
          if (!edge) {
            edge = { id: uid("e"), from: fromId, to: toId, condition: step.condition };
            op.edges.push(edge);
          } else {
            edge.condition = step.condition;
          }
          if (opId === state.currentOpId) {
            renderCanvas();
            syncSelection();
            aiMoveCursorToNode(fromId);
            flashNode(fromId);
            await delay(aiMs(90));
            aiMoveCursorToNode(toId);
            flashNode(toId);
          }
          if (step.note) aiAppendOutput(`✓ ${step.note}`);
          await delay(aiMs(step.ms ?? 180));
          return;
        }

        if (type === "fixCurrentOp") {
          const hasStart = op.nodes.some((n) => n.type === "start");
          const hasEnd = op.nodes.some((n) => n.type === "end");
          if (!hasStart) {
            const minX = op.nodes.reduce((m, n) => Math.min(m, n.x ?? 320), 320);
            const y = op.nodes[0]?.y ?? 220;
            await aiApplyStep({ type: "createNode", opId, node: { type: "start", title: "Start", sub: "", x: minX - 240, y }, note: "Ajouter Start" });
          }
          if (!hasEnd) {
            const maxX = op.nodes.reduce((m, n) => Math.max(m, n.x ?? 0), 320);
            const y = op.nodes[0]?.y ?? 220;
            await aiApplyStep({ type: "createNode", opId, node: { type: "end", title: "End", sub: "", x: maxX + 260, y }, note: "Ajouter End" });
          }
          const nodesSorted = [...op.nodes].sort((a, b) => (a.x ?? 0) - (b.x ?? 0));
          for (let i = 0; i < nodesSorted.length - 1; i++) {
            const a = nodesSorted[i];
            const b = nodesSorted[i + 1];
            const edgeExists = op.edges.some((e) => e.from === a.id && e.to === b.id);
            if (!edgeExists && a.type !== "end" && b.type !== "start") {
              await aiApplyStep({ type: "connect", opId, fromId: a.id, toId: b.id, note: `Relier ${a.title} → ${b.title}` });
            }
          }
          aiAppendOutput("✓ Complétion terminée.");
          return;
        }
      }

      function openManualPdf() {
        try {
          window.open("manual_biopat_mfcs_4_recipe_sbi6030-e200605.pdf", "_blank", "noopener");
        } catch {
          // ignore
        }
      }

      function pickNumber(re, text) {
        const m = String(text || "").match(re);
        if (!m) return null;
        const n = Number(String(m[1]).replace(",", "."));
        return Number.isFinite(n) ? n : null;
      }

      function buildGeneratedOperationsFromPrompt(prompt) {
        const p = String(prompt || "").trim();
        const lower = p.toLowerCase();

        const temp = pickNumber(/(?:temp|temperature)\s*[:=]?\s*([0-9]+(?:[.,][0-9]+)?)/i, p) ?? 37;
        const ph = pickNumber(/(?:p\s*h|ph)\s*[:=]?\s*([0-9]+(?:[.,][0-9]+)?)/i, p) ?? 6.8;
        const po2 = pickNumber(/(?:po2|p02|do)\s*[:=]?\s*([0-9]+(?:[.,][0-9]+)?)/i, p) ?? 35;
        const prepWaitVal = pickNumber(/(?:wait|attendre|attente)\s*([0-9]+)\s*(?:min|minutes|m)\b/i, lower) ?? 30;
        const loopWaitVal = pickNumber(/(?:loop|boucle|repeat).{0,18}([0-9]+)\s*(?:min|minutes|m)\b/i, lower) ?? 1;

        const needFeed = /(feed|fed|glucose|pompe)/i.test(lower);
        const odStop = pickNumber(/(?:od|biomasse)\s*(?:>=|>|=)\s*([0-9]+(?:[.,][0-9]+)?)/i, p);

        const operations = deepClone(PDF_KB.exampleRecipe.operations);

        // Preparation
        const prep = operations.find((o) => o.id === "prep") || operations[0];
        const prepParam = prep?.nodes?.find((n) => n.type === "parameter");
        if (prepParam) {
          prepParam.sub = `TEMP ${temp}°C · pH ${ph}`;
          prepParam.data = prepParam.data || {};
          prepParam.data.parameters = [
            "TEMP.State=remote",
            "TEMP.Mode=auto",
            `TEMP.Setpoint=${temp}`,
            "pH.State=remote",
            "pH.Mode=auto",
            `pH.Setpoint=${ph}`,
          ];
        }
        const prepWait = prep?.nodes?.find((n) => n.type === "wait");
        if (prepWait) {
          prepWait.title = `Wait ${prepWaitVal} min`;
          prepWait.sub = `Durée ${prepWaitVal} min`;
          prepWait.data = prepWait.data || {};
          prepWait.data.duration = prepWaitVal;
          prepWait.data.unit = "min";
        }

        // Inoculation: prefer an Operator prompt phase
        const inoc = operations.find((o) => o.id === "inoc");
        const inocStep = inoc?.nodes?.find((n) => n.type !== "start" && n.type !== "end");
        if (inocStep) {
          inocStep.type = "operator";
          inocStep.sub = inocStep.sub || "Semi-Automatic";
          inocStep.data = inocStep.data || {};
          inocStep.data.mode = inocStep.data.mode || "Semi-Automatic";
          inocStep.data.decisions = inocStep.data.decisions || ["OK", "Stop"];
          inocStep.data.message = inocStep.data.message || "Inoculer la culture puis confirmer.";
        }

        // Batch: update pO2 loop + optional feed/stop
        const batch = operations.find((o) => o.id === "batch");
        const batchStart = batch?.nodes?.find((n) => n.type === "start");
        const batchWait = batch?.nodes?.find((n) => n.type === "wait");
        const batchParam = batch?.nodes?.find((n) => n.type === "parameter");
        const batchEnd = batch?.nodes?.find((n) => n.type === "end");

        if (batchWait) {
          batchWait.title = `Wait ${loopWaitVal} min`;
          batchWait.sub = `Durée ${loopWaitVal} min`;
          batchWait.data = batchWait.data || {};
          batchWait.data.duration = loopWaitVal;
          batchWait.data.unit = "min";
        }
        if (batchParam) {
          batchParam.sub = `pO2 Setpoint ${po2}%`;
          batchParam.data = batchParam.data || {};
          batchParam.data.parameters = ["pO2.State=remote", "pO2.Mode=auto", `pO2.Setpoint=${po2}`];
        }

        if (batch && batchStart && batchWait && batchParam && batchEnd) {
          // Ensure edges exist
          batch.edges = batch.edges || [];
          if (!batch.edges.some((e) => e.from === batchStart.id && e.to === batchWait.id)) {
            batch.edges.unshift({ id: uid("e"), from: batchStart.id, to: batchWait.id });
          }

          const edgeA = batch.edges.find((e) => e.from === batchWait.id && e.to === batchParam.id);
          if (edgeA) edgeA.condition = `pO2.Value < ${po2}% (A)`;
          else batch.edges.push({ id: uid("e"), from: batchWait.id, to: batchParam.id, condition: `pO2.Value < ${po2}% (A)` });

          const edgeB = batch.edges.find((e) => e.from === batchWait.id && e.to === batchWait.id);
          if (edgeB) edgeB.condition = `pO2.Value > ${po2}% (B)`;
          else batch.edges.push({ id: uid("e"), from: batchWait.id, to: batchWait.id, condition: `pO2.Value > ${po2}% (B)` });

          // Tail nodes after "Activate pO2 control"
          const tailNodes = [];
          if (needFeed) {
            tailNodes.push({
              id: uid("batch_prof"),
              type: "profile",
              title: "Profile Feed",
              sub: "ramp 0→X",
              x: batchEnd.x,
              y: batchEnd.y - 10,
              data: { mode: "Automatic", variable: "Feed", interpolation: "Linear", unit: "h", points: [{ t: 0, v: 0 }, { t: 8, v: 1 }] },
            });
            tailNodes.push({
              id: uid("batch_instr"),
              type: "instrument",
              title: "Pump Feed",
              sub: "mL/min",
              x: batchEnd.x + 240,
              y: batchEnd.y,
              data: { mode: "Automatic", phase: "FeedPump", forceRestart: "No" },
            });
          }
          if (odStop != null) {
            const baseX = tailNodes.length ? tailNodes[tailNodes.length - 1].x + 240 : batchEnd.x;
            tailNodes.push({
              id: uid("batch_stop"),
              type: "parameter",
              title: "Stop condition",
              sub: `OD > ${odStop}`,
              x: baseX,
              y: batchEnd.y - 10,
              data: { mode: "Automatic", description: "", parameters: [`OD.Threshold=${odStop}`] },
            });
          }

          // Insert tail nodes before End and rebuild outgoing edges from batchParam
          if (tailNodes.length) {
            const endIdx = batch.nodes.findIndex((n) => n.id === batchEnd.id);
            batch.nodes.splice(endIdx, 0, ...tailNodes);
            batchEnd.x = tailNodes[tailNodes.length - 1].x + 240;
          }

          batch.edges = batch.edges.filter((e) => e.from !== batchParam.id);
          const firstTailId = tailNodes[0]?.id || batchEnd.id;
          batch.edges.push({ id: uid("e"), from: batchParam.id, to: firstTailId });
          for (let i = 0; i < tailNodes.length - 1; i++) batch.edges.push({ id: uid("e"), from: tailNodes[i].id, to: tailNodes[i + 1].id });
          if (tailNodes.length) batch.edges.push({ id: uid("e"), from: tailNodes[tailNodes.length - 1].id, to: batchEnd.id });
        }

        // Keep subtitles in sync when possible
        operations.forEach((op) => op.nodes.forEach((n) => updateNodeSubFromData?.(n)));

        return {
          operations,
          summary: { temp, ph, po2, prepWaitVal, loopWaitVal, needFeed, odStop },
        };
      }

      function aiReply(action, prompt = "") {
        if (action === "pdfSummary") {
          return {
            text: [
              "Synthèse PDF (BioPAT MFCS 4 Recipe Control Module)",
              "",
              "• Types de phase : Start, Parameter, Operator prompt, Profile, Instrument, Wait, End.",
              "• Modes : Automatic vs Semi-Automatic (confirmation utilisateur).",
              "• Transitions : lient des phases et portent une condition (EDIT CONDITION).",
              "",
              "Exemple PDF : Preparation / Inoculation / Batch (pO2).",
            ].join("\n"),
            apply: null,
          };
        }
        if (action === "applyPdfExample") {
          return {
            text: [
              "Appliquer l’exemple PDF sur le workflow :",
              "• Preparation: TEMP 37°C + pH 6.8, Wait 30 min",
              "• Inoculation: Semi-Automatic",
              "• Batch: pO2 < 35% / > 35% avec boucle Wait 1 min + Activate pO2 control",
              "",
              "Clique “Appliquer” pour charger l’exemple.",
            ].join("\n"),
            apply: { type: "replaceWithPdfExample" },
          };
        }
        if (action === "generateRecipe") {
          const question = String(prompt || "").trim();
          if (!question) {
            return {
              text: [
                "Générer recette (démo locale) :",
                "1) Écris ton objectif dans le champ IA (ex: \"Batch pH 7, pO2 35%, feed, fin OD>20\").",
                "2) Clique \"Générer recette\" puis \"Appliquer\".",
              ].join("\n"),
              apply: null,
            };
          }

          const built = buildGeneratedOperationsFromPrompt(question);
          return {
            text: [
              "Génération (basée PDF + mots-clés)",
              `Prompt: ${question}`,
              "",
              `TEMP=${built.summary.temp}°C | pH=${built.summary.ph} | pO2=${built.summary.po2}% | Wait=${built.summary.prepWaitVal} min | Loop=${built.summary.loopWaitVal} min`,
              built.summary.needFeed ? "• Feed: OUI (Profile + Pump)" : "• Feed: non détecté",
              built.summary.odStop != null ? `• Stop: OD > ${built.summary.odStop}` : "• Stop: non détecté",
              "",
              "Clique \"Appliquer\" pour charger la recette générée.",
            ].join("\n"),
            apply: { type: "replaceWithGenerated", operations: built.operations },
          };
        }
        if (action === "completeSteps") {
          const plan = aiBuildCompleteCurrentOpPlan(prompt || "");
          return {
            text: [plan.text, "", "Clique “Appliquer” pour que l’IA crée/édite/relie les phases dans le canvas."].join("\n"),
            actions: plan.actions,
            apply: null,
          };
        }
        if (action === "rewrite") {
          return {
            text:
              "Reformulation : configure TEMP et pH, attends la stabilisation, puis inocule. En batch, surveille pO2 : si < 35% active le contrôle pO2 (35%), sinon boucle Wait 1 min.",
            apply: null,
          };
        }
        if (action === "conditions") {
          const plan = aiBuildPo2ConditionsPlan(prompt || "");
          return {
            text: [
              plan.text,
              "",
              "Je pose/ajuste les transitions et conditions (A/B) sur l’opération Batch.",
              "Clique “Appliquer” pour voir la boucle pO2 apparaître.",
            ].join("\n"),
            actions: plan.actions,
            apply: null,
          };
        }
        return { text: "Action IA inconnue.", apply: null };
      }

      async function askLLM(question) {
        const q = (question || "").trim().toLowerCase();
        if (!q) return "Pose une question.";
        if (q.includes("po2") || q.includes("p02")) return aiReply("conditions").text;
        if (q.includes("wait")) return PDF_KB.phaseTypes.wait;
        if (q.includes("semi")) return "Semi-Automatic : la phase démarre après confirmation utilisateur (PDF).";
        if (q.includes("operator")) return PDF_KB.phaseTypes.operator;
        if (q.includes("parameter")) return PDF_KB.phaseTypes.parameter;
        return "Je peux résumer le PDF, charger l’exemple PDF, ou expliquer les phases/modes. Essaie : “pO2 < 35%”, “Wait phase”, “Operator prompt”.";
      }

      async function aiChatPlan(input) {
        const q = String(input || "").trim();
        const lower = q.toLowerCase();
        if (!q) return { text: "Pose une question.", actions: null };

        const hasQuestion = q.includes("?");
        const wantsAction = /(applique|charge|exemple|pdf|g[ée]n[ée]re|generate|cr[ée]e|ajout|compl[eé]t|condition|po2|p02|wait|attend)/i.test(
          q,
        );

        if (!wantsAction && hasQuestion) {
          return { text: await askLLM(q), actions: null };
        }

        if (/(ouvre|open).*(pdf|manuel)/i.test(q)) {
          openManualPdf();
          return { text: "Ouverture du manuel PDF…", actions: null };
        }

        if (/(applique|charge).*(pdf|exemple)/i.test(q)) {
          const res = aiReply("applyPdfExample");
          return aiPlanFromOperations(PDF_KB.exampleRecipe.operations, res.text);
        }

        if (/(condition|po2|p02)/i.test(q)) {
          const res = aiReply("conditions", q);
          return { text: res.text, actions: res.actions || null };
        }

        if (/(compl[eé]t|complete)/i.test(q)) {
          const res = aiReply("completeSteps", q);
          return { text: res.text, actions: res.actions || null };
        }

        if (/(g[ée]n[ée]re|generate|recette|recipe|temp|temperature|ph|p\\s*h|feed|glucose|od)/i.test(q)) {
          const res = aiReply("generateRecipe", q);
          if (res.apply?.type === "replaceWithGenerated" && Array.isArray(res.apply.operations)) {
            return aiPlanFromOperations(res.apply.operations, res.text);
          }
          return { text: res.text, actions: null };
        }

        if (/(ajoute|ajouter|cr[ée]e|create)/i.test(q)) {
          const op = getCurrentOp();
          if (!op) return { text: "Aucune opération active.", actions: null };
          const opId = op.id;
          const selected = state.selection.nodeId && findNode(op, state.selection.nodeId) ? state.selection.nodeId : null;
          const startId = op.nodes.find((n) => n.type === "start")?.id || op.nodes[0]?.id || null;
          const endId = op.nodes.find((n) => n.type === "end")?.id || null;
          const anchorId = selected && findNode(op, selected)?.type !== "end" ? selected : startId;

          const wantWait = /(wait|attente)/i.test(q);
          const wantParam = /(parameter|param[èe]tre|setpoint|ph|p\\s*h|po2|p02)/i.test(q);
          const wantOp = /(operator|op[ée]rateur|prompt)/i.test(q);

          let nodeType = wantWait ? "wait" : wantOp ? "operator" : wantParam ? "parameter" : null;
          if (!nodeType) return { text: await askLLM(q), actions: null };

          const nodeId = uid("ai");
          const node = { type: nodeType, title: "Phase", sub: "", data: defaultDataForType(nodeType) };

          if (nodeType === "wait") {
            const m = q.match(/([0-9]+(?:[.,][0-9]+)?)\\s*(s|sec|secondes|m|min|minutes|h|heure|heures)\\b/i);
            const val = m ? Number(String(m[1]).replace(",", ".")) : 1;
            const unitRaw = (m?.[2] || "min").toLowerCase();
            const unit = unitRaw.startsWith("h") ? "h" : unitRaw.startsWith("s") ? "sec" : "min";
            node.title = `Wait ${val} ${unit}`;
            node.sub = `Durée ${val} ${unit}`;
            node.data = { mode: "Automatic", duration: val, unit };
          } else if (nodeType === "operator") {
            node.title = "Prompt opérateur";
            node.sub = "Semi-Automatic";
            node.data = { mode: "Semi-Automatic", description: "", decisions: ["OK", "Stop"], message: "Confirmer puis continuer." };
          } else if (nodeType === "parameter") {
            const ph = pickNumber(/(?:p\\s*h|ph)\\s*[:=]?\\s*([0-9]+(?:[.,][0-9]+)?)/i, q);
            const po2 = pickNumber(/(?:po2|p02)\\s*[:=]?\\s*([0-9]+(?:[.,][0-9]+)?)/i, q);
            if (ph != null) {
              node.title = "Régule pH";
              node.sub = `pH Setpoint ${ph}`;
              node.data = { mode: "Automatic", description: "", parameters: [`pH.Setpoint=${ph}`] };
            } else if (po2 != null) {
              node.title = "Régule pO2";
              node.sub = `pO2 Setpoint ${po2}%`;
              node.data = { mode: "Automatic", description: "", parameters: ["pO2.State=remote", "pO2.Mode=auto", `pO2.Setpoint=${po2}`] };
            } else {
              node.title = "Parameter phase";
              node.sub = "Setpoints";
              node.data = { mode: "Automatic", description: "", parameters: [] };
            }
          }

          const actions = [
            { type: "selectOp", opId, note: `Ouvrir : ${op.name}` },
            { type: "createNode", opId, nodeId, node, select: true, nearId: anchorId, note: `Ajouter : ${node.title}` },
          ];
          if (anchorId) actions.push({ type: "connect", opId, fromId: anchorId, toId: nodeId, note: "Relier depuis l’ancre" });
          if (endId && endId !== anchorId) actions.push({ type: "connect", opId, fromId: nodeId, toId: endId, note: "Relier vers End" });

          return { text: `Plan IA — Ajout d’une phase (${nodeType}) dans "${op.name}"`, actions };
        }

        return { text: await askLLM(q), actions: null };
      }

      function applyAiAction(apply) {
        if (!apply) return;
        if (apply.type === "replaceWithPdfExample") {
          saveHistory();
          const ex = PDF_KB.exampleRecipe.operations;
          state.operations = ex.map((op) => ({
            id: op.id,
            name: op.name,
            nodes: op.nodes.map((n) => ({ ...n, data: { ...(n.data || {}) } })),
            edges: op.edges.map((e) => ({ ...e })),
          }));
          state.currentOpId = state.operations[0]?.id || "prep";
          state.selection = { nodeId: null, nodeIds: new Set() };
          cancelConnect();
          renderOperations();
          renderWorkspaceHeader();
          renderCanvas();
          clampNodesToCanvas();
          renderCanvas();
          syncSelection();
        }
      }

      function bindEvents() {
        document.querySelectorAll("[data-collapse]").forEach((btn) => {
          btn.addEventListener("click", () => toggleCollapse(btn.dataset.collapse));
        });
        document.querySelectorAll("#dockRow .dockBtn[data-dock]").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.preventDefault();
            setDockOpen(btn.dataset.dock);
          });
        });
        window.addEventListener("pointerdown", (e) => {
          if (!uiPrefs.wideCanvas) return;
          if (!dock.open) return;
          const t = e.target;
          if (t && (t.closest("#dockRow") || t.closest(".dockPanelWrap"))) return;
          closeDock();
        });
        window.addEventListener("focusin", (e) => {
          const t = e.target;
          if (!t) return;
          if (t.tagName === "INPUT" || t.tagName === "TEXTAREA") lastTextTarget = t;
        });

        byId("recipeSearch").addEventListener("input", renderRecipes);
        byId("checkMode").addEventListener("change", renderRecipes);

        byId("newRecipeBtn").addEventListener("click", () => {
          const name = prompt("Nom de la recette ?", "New Recipe");
          if (!name) return;
          saveHistory();
          stashCurrentRecipe();
          const id = uid("r");
          recipeCatalog.unshift({ id, name });
          state.recipeId = id;
          state.operations = freshOperations();
          state.currentOpId = "prep";
          state.selection = { nodeId: null, nodeIds: new Set() };
          cancelConnect();
          renderAll();
          persistSoon();
        });


        byId("addOperationBtn").addEventListener("click", () => {
          saveHistory();
          const opId = uid("op");
          state.operations.push({ id: opId, name: "New operation", nodes: [], edges: [] });
          state.currentOpId = opId;
          state.selection = { nodeId: null, nodeIds: new Set() };
          cancelConnect();
          renderOperations();
          renderWorkspaceHeader();
          renderCanvas();
          syncSelection();
        });


        byId("previewBtn").addEventListener("click", simulateOperation);
        byId("toolPlay").addEventListener("click", simulateOperation);

        // Diff mode buttons
        byId("diffBtn")?.addEventListener("click", () => {
          try {
            if (typeof diffState !== "undefined" && diffState.active) exitDiffMode();
            else openHistory();
          } catch(err) { console.error("Diff error:", err); }
        });
        byId("diffCloseBtn")?.addEventListener("click", () => {
          try { exitDiffMode(); } catch(err) { console.error("Diff close error:", err); }
        });

        // History modal
        byId("closeHistory")?.addEventListener("click", () => { try { closeHistory(); } catch(e) { console.error(e); } });
        byId("histClose")?.addEventListener("click", () => { try { closeHistory(); } catch(e) { console.error(e); } });
        byId("histCompare")?.addEventListener("click", () => { try { compareCheckedVersions(); } catch(e) { console.error(e); } });
        byId("histNewBranch")?.addEventListener("click", () => { try { createBranch(); } catch(e) { console.error(e); } });
        byId("histBranchSelect")?.addEventListener("change", () => {
          try { histState.checked.clear(); renderHistoryVersions(); } catch(e) { console.error(e); }
        });
        byId("toolHand").addEventListener("click", () => {
          uiPrefs.handMode = !uiPrefs.handMode;
          savePrefs();
          applyPrefsToDom();
        });
        byId("toolZoomOut").addEventListener("click", () => {
          const r = dom.canvas.getBoundingClientRect();
          const center = { x: r.width / 2, y: r.height / 2 };
          zoomAt(center, getView().zoom / 1.18);
        });
        byId("toolZoomIn").addEventListener("click", () => {
          const r = dom.canvas.getBoundingClientRect();
          const center = { x: r.width / 2, y: r.height / 2 };
          zoomAt(center, getView().zoom * 1.18);
        });
        byId("toolFit").addEventListener("click", () => fitViewToOp(state.currentOpId));
        byId("toolCompact").addEventListener("click", () => {
          uiPrefs.compactNodes = !uiPrefs.compactNodes;
          savePrefs();
          applyPrefsToDom();
          renderCanvas();
          syncSelection();
        });
        byId("toolWide").addEventListener("click", () => {
          uiPrefs.wideCanvas = !uiPrefs.wideCanvas;
          savePrefs();
          applyPrefsToDom();
          requestAnimationFrame(() => updateWires());
        });
        byId("toolLayoutH").addEventListener("click", () => autoLayoutCurrentOp("h"));
        byId("toolLayoutV").addEventListener("click", () => autoLayoutCurrentOp("v"));

        byId("toolUndo").addEventListener("click", () => {
          if (!state.history.length) return;
          state.future.push(snapshot());
          const snap = state.history.pop();
          restoreSnapshot(snap);
        });
        byId("toolRedo").addEventListener("click", () => {
          if (!state.future.length) return;
          state.history.push(snapshot());
          const snap = state.future.pop();
          restoreSnapshot(snap);
        });

        // AI drawer
        [byId("openAI"), byId("libAI")].filter(Boolean).forEach((btn) =>
          btn.addEventListener("click", () => toggleAI(true)),
        );
        byId("closeAI").addEventListener("click", () => toggleAI(false));
        document.querySelectorAll(".aiModeBtn").forEach((btn) => {
          btn.addEventListener("click", () => setAiMode(btn.dataset.aiMode, { persist: true }));
        });
        setAiMode(uiPrefs.aiMode || "chat", { persist: false });
        renderAiVars();
        byId("aiRunPlan")?.addEventListener("click", () => byId("applyAI")?.click());
        byId("aiClearPlan").addEventListener("click", clearAiPlan);
        byId("openPdfBtn")?.addEventListener("click", openManualPdf);

        const speedSel = byId("aiSpeed");
        if (speedSel) {
          speedSel.value = String(uiPrefs.aiSpeed ?? 1.35);
          speedSel.addEventListener("change", () => {
            uiPrefs.aiSpeed = Number(speedSel.value) || 1.35;
            savePrefs();
            applyAiSpeedCss();
          });
        }

        document.querySelectorAll(".aiAction").forEach((btn) => {
          btn.addEventListener("click", () => {
            const demo = btn.dataset.demo;
            if (demo) {
              if (demo === "demo_fix") {
                const plan = {
                  text: "Démo — IA complète l’opération courante",
                  actions: [{ type: "fixCurrentOp", opId: state.currentOpId, note: "Compléter l’opération courante" }],
                };
                aiSetPlan(plan);
                if (plan.actions) runAiActions(plan.actions, { label: "Démo" });
                return;
              }

              if (demo === "demo_feed") {
                const built = buildGeneratedOperationsFromPrompt("feed po2 35 loop 1");
                const demoOps = built.operations.filter((o) => o.id === "batch");
                const plan = aiPlanFromOperations(demoOps, "Démo — Batch + Feed (Profile + Pump)");
                aiSetPlan(plan);
                if (plan.actions) runAiActions(plan.actions, { label: "Démo" });
                return;
              }

              if (demo === "demo_tune") {
                const demoPrompt = "temp 36 pH 7.2 po2 40 wait 25 loop 2";
                const plan = aiBuildCompleteCurrentOpPlan(demoPrompt);
                plan.text = [`Démo — IA ajuste setpoints`, `Prompt: ${demoPrompt}`, "", plan.text].join("\n");
                aiSetPlan(plan);
                if (plan.actions) runAiActions(plan.actions, { label: "Démo" });
                return;
              }

              if (demo === "demo_operator") {
                const op = {
                  id: "operator_prompt",
                  name: "Operator prompt phase",
                  nodes: [
                    { id: "op_start", type: "start", title: "Start", sub: "", x: 220, y: 220, data: { mode: "Automatic" } },
                    {
                      id: "op_prompt",
                      type: "operator",
                      title: "Operator prompt",
                      sub: "Décisions : Yes / No",
                      x: 440,
                      y: 210,
                      data: {
                        mode: "Semi-Automatic",
                        description: "",
                        decisions: ["Yes", "No"],
                        message: "Ajouter une base (ou continuer sans) ?",
                      },
                    },
                    {
                      id: "op_yes",
                      type: "parameter",
                      title: "Add base",
                      sub: "pH Setpoint 7.0",
                      x: 720,
                      y: 160,
                      data: { mode: "Automatic", description: "", parameters: ["pH.Setpoint=7.0"] },
                    },
                    { id: "op_no", type: "wait", title: "Wait 5 min", sub: "Durée 5 min", x: 720, y: 260, data: { mode: "Automatic", duration: 5, unit: "min" } },
                    { id: "op_end", type: "end", title: "End", sub: "", x: 980, y: 220, data: { mode: "Automatic" } },
                  ],
                  edges: [
                    { id: "op_e1", from: "op_start", to: "op_prompt" },
                    { id: "op_e2", from: "op_prompt", to: "op_yes", condition: "Decision == Yes" },
                    { id: "op_e3", from: "op_prompt", to: "op_no", condition: "Decision == No" },
                    { id: "op_e4", from: "op_yes", to: "op_end" },
                    { id: "op_e5", from: "op_no", to: "op_end" },
                  ],
                };

                const plan = aiPlanFromOperations([op], "Démo — Operator prompt (décisions + transitions)");
                if (plan.actions) plan.actions.push({ type: "layout", direction: "h", note: "Organiser horizontalement" });
                aiSetPlan(plan);
                if (plan.actions) runAiActions(plan.actions, { label: "Démo" });
                return;
              }

              if (demo === "demo_jump") {
                const op = {
                  id: "jump_link",
                  name: "Jump link",
                  nodes: [
                    { id: "jl_start", type: "start", title: "Start", sub: "", x: 220, y: 240, data: { mode: "Automatic" } },
                    { id: "jl_wait", type: "wait", title: "Wait 1 min", sub: "Durée 1 min", x: 460, y: 230, data: { mode: "Automatic", duration: 1, unit: "min" } },
                    { id: "jl_end", type: "end", title: "End", sub: "", x: 760, y: 240, data: { mode: "Automatic" } },
                  ],
                  edges: [
                    { id: "jl_e1", from: "jl_start", to: "jl_wait" },
                    { id: "jl_e2", from: "jl_wait", to: "jl_end", condition: "OD.Value ≥ 10" },
                    { id: "jl_e3", from: "jl_wait", to: "jl_wait", condition: "OD.Value < 10 (jump)" },
                  ],
                };

                const plan = aiPlanFromOperations([op], "Démo — Jump link (boucle + sortie)");
                if (plan.actions) plan.actions.push({ type: "layout", direction: "h", note: "Organiser horizontalement" });
                aiSetPlan(plan);
                if (plan.actions) runAiActions(plan.actions, { label: "Démo" });
                return;
              }

              if (demo === "demo_vertical") {
                const demoOps = PDF_KB.exampleRecipe.operations.filter((o) => o.id === "prep");
                const plan = aiPlanFromOperations(demoOps, "Démo — Layout vertical (ports haut/bas)");
                if (plan.actions) plan.actions.push({ type: "layout", direction: "v", note: "Organiser verticalement" });
                aiSetPlan(plan);
                if (plan.actions) runAiActions(plan.actions, { label: "Démo" });
                return;
              }

              if (demo === "demo_reset_calc") {
                const resetOp = {
                  id: "reset_calc",
                  name: "Reset calculation",
                  nodes: [
                    { id: "rc_start", type: "start", title: "Start", sub: "", x: 220, y: 240, data: { mode: "Automatic" } },
                    { id: "rc_wait", type: "wait", title: "Wait 2 min", sub: "Durée 2 min", x: 440, y: 240, data: { mode: "Automatic", duration: 2, unit: "min" } },
                    {
                      id: "rc_reset",
                      type: "parameter",
                      title: "Reset calc. O2 Totalizer",
                      sub: "Reset O2_Totalizer.Value → 0",
                      x: 660,
                      y: 240,
                      data: { mode: "Automatic", description: "", parameters: ["RESET(O2_Totalizer.Value;0)"] },
                    },
                    {
                      id: "rc_calc",
                      type: "calc",
                      title: "Totalize O2",
                      sub: "Totalizer_O2 = getValue(O2_Totalizer.Value;0) + O2_Flow.Value × (calcCycle() / 60) ml",
                      x: 820,
                      y: 240,
                      data: {
                        mode: "Automatic",
                        description: "",
                        target: "Totalizer_O2",
                        formula: "getValue(O2_Totalizer.Value;0) + O2_Flow.Value × (calcCycle() / 60)",
                        unit: "ml",
                      },
                    },
                    { id: "rc_end", type: "end", title: "End", sub: "", x: 980, y: 240, data: { mode: "Automatic" } },
                  ],
                  edges: [
                    { id: "rc_e1", from: "rc_start", to: "rc_wait" },
                    { id: "rc_e2", from: "rc_wait", to: "rc_reset" },
                    { id: "rc_e3", from: "rc_reset", to: "rc_calc" },
                    { id: "rc_e4", from: "rc_calc", to: "rc_end" },
                  ],
                };

                const plan = aiPlanFromOperations([resetOp], "Démo — Reset calculation (getValue + calcCycle)");
                if (plan.actions) plan.actions.push({ type: "layout", direction: "h", note: "Organiser horizontalement" });
                aiSetPlan(plan);
                if (plan.actions) runAiActions(plan.actions, { label: "Démo" });
                return;
              }

              const pick = (opId) => PDF_KB.exampleRecipe.operations.filter((o) => !opId || o.id === opId);
              const demoOps = demo === "demo_prep" ? pick("prep") : demo === "demo_batch" ? pick("batch") : pick(null);
              const title =
                demo === "demo_prep"
                  ? "Démo — Preparation (TEMP/pH + Wait)"
                  : demo === "demo_batch"
                    ? "Démo — Batch (boucle pO2 + conditions)"
                    : "Démo — Recette PDF complète (pas à pas)";
              const plan = aiPlanFromOperations(demoOps, title);
              aiSetPlan(plan);
              if (plan.actions) runAiActions(plan.actions, { label: "Démo" });
              return;
            }

            const action = btn.dataset.ai;
            if (!action) return;
            const prompt = byId("aiQ")?.value || "";
            const res = aiReply(action, prompt);

            if (action === "pdfSummary") openManualPdf();

            if (res.apply?.type === "replaceWithPdfExample") {
              aiSetPlan(aiPlanFromOperations(PDF_KB.exampleRecipe.operations, res.text));
              return;
            }
            if (res.apply?.type === "replaceWithGenerated" && Array.isArray(res.apply.operations)) {
              aiSetPlan(aiPlanFromOperations(res.apply.operations, res.text));
              return;
            }

            if (Array.isArray(res.actions) && res.actions.length) {
              aiSetPlan({ text: res.text, actions: res.actions });
              return;
            }

            aiSetPlan({ text: res.text, actions: null });
          });
        });

        byId("aiAskBtn").addEventListener("click", async () => {
          const q = byId("aiQ").value.trim();
          if (!q) return;
          const plan = await aiChatPlan(q);
          aiSetPlan(plan);
        });
        byId("aiQ").addEventListener("keydown", (e) => {
          if (e.key === "Enter") byId("aiAskBtn").click();
        });

        byId("copyAI").addEventListener("click", async () => {
          const text = byId("aiOut").textContent || "";
          try {
            await navigator.clipboard.writeText(text);
          } catch {
            // ignore
          }
        });
        byId("applyAI").addEventListener("click", () => runAiActions(state.ai.lastActions, { label: "Appliquer" }));
        aiUpdateApplyButton();

        // formula editor modal
        byId("closeFx")?.addEventListener("click", closeFormulaEditor);
        byId("fxCancel")?.addEventListener("click", closeFormulaEditor);
        byId("fxSave")?.addEventListener("click", () => {
          const text = byId("fxText")?.value || "";
          if (fxState.onCommit) fxState.onCommit(text);
          closeFormulaEditor();
        });
        byId("fxValidate")?.addEventListener("click", fxUpdatePreview);
        byId("fxText")?.addEventListener("input", fxUpdatePreview);
        byId("fxVarSearch")?.addEventListener("input", (e) => renderFxVars(e.target.value));
        byId("formulaBackdrop")?.addEventListener("click", (e) => {
          if (e.target === byId("formulaBackdrop")) closeFormulaEditor();
        });

       // select variable modal
        byId("closeVar")?.addEventListener("click", () => closeVarPicker({ restore: true }));
        byId("varCancel")?.addEventListener("click", () => closeVarPicker({ restore: true }));
        byId("varOk")?.addEventListener("click", commitVarPickerSelection);
        byId("varReset")?.addEventListener("click", () => {
          const s = byId("varSearch");
          if (!s) return;
          s.value = "";
          s.focus();
          renderVarPicker();
        });
        byId("varSearch")?.addEventListener("input", renderVarPicker);
        byId("varSearch")?.addEventListener("keydown", (e) => {
          if (e.key === "ArrowDown") {
            e.preventDefault();
            varPickerStep(+1);
            byId("varList")?.focus();
          }
          if (e.key === "ArrowUp") {
            e.preventDefault();
            varPickerStep(-1);
            byId("varList")?.focus();
          }
          if (e.key === "Enter") {
            e.preventDefault();
            commitVarPickerSelection();
          }
          if (e.key === "Escape") {
            e.preventDefault();
            closeVarPicker({ restore: true });
          }
        });
        byId("varList")?.addEventListener("keydown", (e) => {
          if (e.key === "ArrowDown") {
            e.preventDefault();
            varPickerStep(+1);
          }
          if (e.key === "ArrowUp") {
            e.preventDefault();
            varPickerStep(-1);
          }
          if (e.key === "Enter") {
            e.preventDefault();
            commitVarPickerSelection();
          }
          if (e.key === "Escape") {
            e.preventDefault();
            closeVarPicker({ restore: true });
          }
        });
        byId("varBackdrop")?.addEventListener("click", (e) => {
          if (e.target === byId("varBackdrop")) closeVarPicker({ restore: true });
        });

        // select phase modal (instrument)
        byId("closePhase")?.addEventListener("click", () => closePhasePicker({ restore: true }));
        byId("phaseCancel")?.addEventListener("click", () => closePhasePicker({ restore: true }));
        byId("phaseOk")?.addEventListener("click", commitPhasePickerSelection);
        byId("phaseReset")?.addEventListener("click", () => {
          const s = byId("phaseSearch");
          if (!s) return;
          s.value = "";
          s.focus();
          renderPhasePicker();
        });
        byId("phaseSearch")?.addEventListener("input", renderPhasePicker);
        byId("phaseSearch")?.addEventListener("keydown", (e) => {
          if (e.key === "ArrowDown") {
            e.preventDefault();
            phasePickerStep(+1);
            byId("phaseList")?.focus();
          }
          if (e.key === "ArrowUp") {
            e.preventDefault();
            phasePickerStep(-1);
            byId("phaseList")?.focus();
          }
          if (e.key === "Enter") {
            e.preventDefault();
            commitPhasePickerSelection();
          }
          if (e.key === "Escape") {
            e.preventDefault();
            closePhasePicker({ restore: true });
          }
        });
        byId("phaseList")?.addEventListener("keydown", (e) => {
          if (e.key === "ArrowDown") {
            e.preventDefault();
            phasePickerStep(+1);
          }
          if (e.key === "ArrowUp") {
            e.preventDefault();
            phasePickerStep(-1);
          }
          if (e.key === "Enter") {
            e.preventDefault();
            commitPhasePickerSelection();
          }
          if (e.key === "Escape") {
            e.preventDefault();
            closePhasePicker({ restore: true });
          }
        });
        byId("phaseBackdrop")?.addEventListener("click", (e) => {
          if (e.target === byId("phaseBackdrop")) closePhasePicker({ restore: true });
        });

        // select calculation modal
        byId("closeCalc")?.addEventListener("click", () => closeCalcPicker({ restore: true }));
        byId("calcCancel")?.addEventListener("click", () => closeCalcPicker({ restore: true }));
        byId("calcOk")?.addEventListener("click", commitCalcPickerSelection);
        byId("calcReset")?.addEventListener("click", () => {
          const s = byId("calcSearch");
          if (!s) return;
          s.value = "";
          s.focus();
          renderCalcPicker();
        });
        byId("calcSearch")?.addEventListener("input", renderCalcPicker);
        byId("calcSearch")?.addEventListener("keydown", (e) => {
          if (e.key === "ArrowDown") {
            e.preventDefault();
            calcPickerStep(+1);
            byId("calcList")?.focus();
          }
          if (e.key === "ArrowUp") {
            e.preventDefault();
            calcPickerStep(-1);
            byId("calcList")?.focus();
          }
          if (e.key === "Enter") {
            e.preventDefault();
            commitCalcPickerSelection();
          }
          if (e.key === "Escape") {
            e.preventDefault();
            closeCalcPicker({ restore: true });
          }
        });
        byId("calcList")?.addEventListener("keydown", (e) => {
          if (e.key === "ArrowDown") {
            e.preventDefault();
            calcPickerStep(+1);
          }
          if (e.key === "ArrowUp") {
            e.preventDefault();
            calcPickerStep(-1);
          }
          if (e.key === "Enter") {
            e.preventDefault();
            commitCalcPickerSelection();
          }
          if (e.key === "Escape") {
            e.preventDefault();
            closeCalcPicker({ restore: true });
          }
        });
        byId("calcBackdrop")?.addEventListener("click", (e) => {
          if (e.target === byId("calcBackdrop")) closeCalcPicker({ restore: true });
        });

        // modal
        byId("closeModal").addEventListener("click", closeEditor);
        byId("modalBackdrop").addEventListener("click", (e) => {
          if (e.target === byId("modalBackdrop")) closeEditor();
        });
        byId("saveNodeBtn").addEventListener("click", saveEditor);
        byId("deleteNodeBtn").addEventListener("click", deleteEditingNode);

        // keyboard shortcuts
        window.addEventListener("keydown", (e) => {
          if (e.code === "Space") {
            const t = e.target;
            const typing =
              t && (t.tagName === "INPUT" || t.tagName === "TEXTAREA" || t.isContentEditable);
            if (!typing) {
              keyState.space = true;
              e.preventDefault();
            }
          }
          if (e.key === "Escape") {
            if (byId("formulaBackdrop")?.classList.contains("active")) closeFormulaEditor();
            if (byId("varBackdrop")?.classList.contains("active")) closeVarPicker({ restore: true });
            if (byId("phaseBackdrop")?.classList.contains("active")) closePhasePicker({ restore: true });
            if (byId("calcBackdrop")?.classList.contains("active")) closeCalcPicker({ restore: true });
            if (byId("modalBackdrop").classList.contains("active")) closeEditor();
            closeDock();
            cancelConnect();
            toggleAI(false);
          }
          if (e.key === "Delete" || e.key === "Backspace") {
            const t = e.target;
            const typing =
              t && (t.tagName === "INPUT" || t.tagName === "TEXTAREA" || t.isContentEditable);
            const modalOpen =
              byId("modalBackdrop")?.classList.contains("active") ||
              byId("formulaBackdrop")?.classList.contains("active") ||
              byId("varBackdrop")?.classList.contains("active") ||
              byId("phaseBackdrop")?.classList.contains("active") ||
              byId("calcBackdrop")?.classList.contains("active");
            if (!typing && !modalOpen) {
              if (ensureSelectionSet().size) {
                e.preventDefault();
                deleteSelectedNodes();
                return;
              }
              if (state.uiFocusArea === "op") {
                e.preventDefault();
                deleteOperation(state.currentOpId);
                return;
              }
              if (state.uiFocusArea === "recipe") {
                e.preventDefault();
                deleteRecipe(state.recipeId);
              }
            }
          }
          if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "a") {
            const t = e.target;
            const typing =
              t && (t.tagName === "INPUT" || t.tagName === "TEXTAREA" || t.isContentEditable);
            const modalOpen =
              byId("modalBackdrop")?.classList.contains("active") ||
              byId("formulaBackdrop")?.classList.contains("active") ||
              byId("varBackdrop")?.classList.contains("active") ||
              byId("phaseBackdrop")?.classList.contains("active") ||
              byId("calcBackdrop")?.classList.contains("active");
            if (!typing && !modalOpen) {
              e.preventDefault();
              const op = getCurrentOp();
              if (!op) return;
              state.selection.nodeIds = new Set(op.nodes.map((n) => n.id));
              state.selection.nodeId = op.nodes[op.nodes.length - 1]?.id || null;
              syncSelection();
            }
          }
          if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "k") {
            e.preventDefault();
            toggleAI(true);
            byId("aiQ")?.focus();
          }
          if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "z") {
            e.preventDefault();
            byId("toolUndo").click();
          }
          if (
            (e.ctrlKey || e.metaKey) &&
            (e.key.toLowerCase() === "y" || (e.shiftKey && e.key.toLowerCase() === "z"))
          ) {
            e.preventDefault();
            byId("toolRedo").click();
          }
        });

        window.addEventListener("resize", () => updateWires());

        window.addEventListener("keyup", (e) => {
          if (e.code === "Space") keyState.space = false;
        });
      }

      // init
      loadPrefs();
      applyPrefsToDom();

      let restored = false;
      const stored = loadStore();
      if (stored) {
        try {
          restoreSnapshot(stored);
          restored = true;
        } catch {
          try {
            localStorage.removeItem(STORE_KEY);
          } catch {
            // ignore
          }
        }
      }
      // Force re-seed if version is outdated (new rich recipe + diff feature)
      const SEED_VERSION = "diff_v4";
      try {
        if (localStorage.getItem("workflow_seed_ver") !== SEED_VERSION) {
          restored = false;
          localStorage.removeItem(STORE_KEY);
        }
      } catch {}
      if (!restored) {
        seedLikeImage();
        try { localStorage.setItem("workflow_seed_ver", SEED_VERSION); } catch {}
      }
      // Diff & history state must be declared BEFORE renderAll/bindEvents
      // to avoid const TDZ errors when renderCanvas checks diffState.active
      const diffState = {
        active: false,
        oldOps: null,
        newOps: null,
        oldLabel: "v1",
        newLabel: "v2",
        diffMap: new Map(),
      };
      const histState = { checked: new Set() };

      bindDnD();
      bindCanvasViewport();
      bindEvents();
      if (!restored) renderAll();

      // ===== VERSION HISTORY & DIFF VISUAL MODE =====

      // --- Full versioned recipe database ---
      const versionStore = {
        "grow-a": {
          currentBranch: "main",
          branches: {
            main: {
              versions: [
                {
                  ver: "1.0", date: "2026-01-08", author: "Dr. Martin", status: "approved",
                  message: "Version initiale - Preparation + Inoculation",
                  operations: [
                    {
                      id: "prep", name: "Preparation",
                      nodes: [
                        { id: "s1", type: "start", title: "Start", sub: "", x: 80, y: 200, data: { mode: "Automatic" } },
                        { id: "p1", type: "parameter", title: "Set temperature", sub: "TEMP 37\u00B0C", x: 300, y: 190,
                          data: { mode: "Automatic", parameters: ["TEMP.State=remote","TEMP.Mode=auto","TEMP.Setpoint=37"] } },
                        { id: "w1", type: "wait", title: "Wait 20 min", sub: "Dur\u00E9e 20 min", x: 560, y: 190, data: { mode: "Automatic", duration: 20, unit: "min" } },
                        { id: "e1", type: "end", title: "End", sub: "", x: 800, y: 200, data: { mode: "Automatic" } },
                      ],
                      edges: [
                        { id: "e1a", from: "s1", to: "p1" },
                        { id: "e2a", from: "p1", to: "w1" },
                        { id: "e3a", from: "w1", to: "e1" },
                      ]
                    },
                    {
                      id: "inoc", name: "Inoculation",
                      nodes: [
                        { id: "is1", type: "start", title: "Start", sub: "", x: 80, y: 200, data: { mode: "Automatic" } },
                        { id: "iop", type: "operator", title: "Inoculate", sub: "Semi-Automatic", x: 300, y: 190, data: { mode: "Semi-Automatic", decisions: ["OK"], message: "Inoculer le bior\u00E9acteur" } },
                        { id: "ie1", type: "end", title: "End", sub: "", x: 560, y: 200, data: { mode: "Automatic" } },
                      ],
                      edges: [
                        { id: "ie1a", from: "is1", to: "iop" },
                        { id: "ie2a", from: "iop", to: "ie1" },
                      ]
                    }
                  ]
                },
                {
                  ver: "1.1", date: "2026-01-10", author: "Nicolas", status: "draft",
                  message: "Ajout contr\u00F4le pH dans Preparation",
                  operations: [
                    {
                      id: "prep", name: "Preparation",
                      nodes: [
                        { id: "s1", type: "start", title: "Start", sub: "", x: 80, y: 200, data: { mode: "Automatic" } },
                        { id: "p1", type: "parameter", title: "Set temperature and pH", sub: "TEMP 37\u00B0C \u00B7 pH 6.8", x: 300, y: 190,
                          data: { mode: "Automatic", parameters: ["TEMP.State=remote","TEMP.Mode=auto","TEMP.Setpoint=37","pH.State=remote","pH.Mode=auto","pH.Setpoint=6.8"] } },
                        { id: "w1", type: "wait", title: "Wait 30 min", sub: "Dur\u00E9e 30 min", x: 560, y: 190, data: { mode: "Automatic", duration: 30, unit: "min" } },
                        { id: "e1", type: "end", title: "End", sub: "", x: 800, y: 200, data: { mode: "Automatic" } },
                      ],
                      edges: [
                        { id: "e1a", from: "s1", to: "p1" },
                        { id: "e2a", from: "p1", to: "w1" },
                        { id: "e3a", from: "w1", to: "e1" },
                      ]
                    },
                    {
                      id: "inoc", name: "Inoculation",
                      nodes: [
                        { id: "is1", type: "start", title: "Start", sub: "", x: 80, y: 200, data: { mode: "Automatic" } },
                        { id: "iop", type: "operator", title: "Inoculate", sub: "Semi-Automatic", x: 300, y: 190, data: { mode: "Semi-Automatic", decisions: ["OK"], message: "Inoculer le bior\u00E9acteur" } },
                        { id: "ie1", type: "end", title: "End", sub: "", x: 560, y: 200, data: { mode: "Automatic" } },
                      ],
                      edges: [
                        { id: "ie1a", from: "is1", to: "iop" },
                        { id: "ie2a", from: "iop", to: "ie1" },
                      ]
                    }
                  ]
                },
                {
                  ver: "2.0", date: "2026-01-12", author: "Nicolas", status: "approved",
                  message: "Ajout op\u00E9ration Batch avec contr\u00F4le pO2 + boucle",
                  operations: [
                    {
                      id: "prep", name: "Preparation",
                      nodes: [
                        { id: "s1", type: "start", title: "Start", sub: "", x: 80, y: 200, data: { mode: "Automatic" } },
                        { id: "p1", type: "parameter", title: "Set temperature and pH", sub: "TEMP 37\u00B0C \u00B7 pH 6.8", x: 300, y: 190,
                          data: { mode: "Automatic", parameters: ["TEMP.State=remote","TEMP.Mode=auto","TEMP.Setpoint=37","pH.State=remote","pH.Mode=auto","pH.Setpoint=6.8"] } },
                        { id: "w1", type: "wait", title: "Wait 30 min", sub: "Dur\u00E9e 30 min", x: 560, y: 190, data: { mode: "Automatic", duration: 30, unit: "min" } },
                        { id: "e1", type: "end", title: "End", sub: "", x: 800, y: 200, data: { mode: "Automatic" } },
                      ],
                      edges: [
                        { id: "e1a", from: "s1", to: "p1" },
                        { id: "e2a", from: "p1", to: "w1" },
                        { id: "e3a", from: "w1", to: "e1" },
                      ]
                    },
                    {
                      id: "inoc", name: "Inoculation",
                      nodes: [
                        { id: "is1", type: "start", title: "Start", sub: "", x: 80, y: 200, data: { mode: "Automatic" } },
                        { id: "iop", type: "operator", title: "Inoculate", sub: "Semi-Automatic", x: 300, y: 190, data: { mode: "Semi-Automatic", decisions: ["OK"], message: "Inoculer le bior\u00E9acteur" } },
                        { id: "ie1", type: "end", title: "End", sub: "", x: 560, y: 200, data: { mode: "Automatic" } },
                      ],
                      edges: [
                        { id: "ie1a", from: "is1", to: "iop" },
                        { id: "ie2a", from: "iop", to: "ie1" },
                      ]
                    },
                    {
                      id: "batch", name: "Batch",
                      nodes: [
                        { id: "bs1", type: "start", title: "Start", sub: "", x: 80, y: 200, data: { mode: "Automatic" } },
                        { id: "bw1", type: "wait", title: "Wait 1 min", sub: "Dur\u00E9e 1 min", x: 280, y: 190, data: { mode: "Automatic", duration: 1, unit: "min" } },
                        { id: "bp1", type: "parameter", title: "Activate pO2 control", sub: "pO2 35%", x: 500, y: 130,
                          data: { mode: "Automatic", parameters: ["pO2.State=remote","pO2.Mode=auto","pO2.Setpoint=35"] } },
                        { id: "be1", type: "end", title: "End", sub: "", x: 740, y: 200, data: { mode: "Automatic" } },
                      ],
                      edges: [
                        { id: "be1a", from: "bs1", to: "bw1", condition: "pO2.Value < 35%" },
                        { id: "be2a", from: "bw1", to: "bp1", condition: "pO2.Value < 35%" },
                        { id: "be3a", from: "bw1", to: "bw1", condition: "pO2.Value >= 35%" },
                        { id: "be4a", from: "bp1", to: "be1" },
                      ]
                    }
                  ]
                },
                {
                  ver: "2.1", date: "2026-01-14", author: "Dr. Martin", status: "locked",
                  message: "Validation finale + augment wait \u00E0 45 min + ajout profil temp",
                  operations: [
                    {
                      id: "prep", name: "Preparation",
                      nodes: [
                        { id: "s1", type: "start", title: "Start", sub: "", x: 80, y: 200, data: { mode: "Automatic" } },
                        { id: "p1", type: "parameter", title: "Set temperature and pH", sub: "TEMP 37\u00B0C \u00B7 pH 6.8", x: 300, y: 140,
                          data: { mode: "Automatic", parameters: ["TEMP.State=remote","TEMP.Mode=auto","TEMP.Setpoint=37","pH.State=remote","pH.Mode=auto","pH.Setpoint=6.8"] } },
                        { id: "pf1", type: "profile", title: "Temp ramp", sub: "TEMP 25\u2192 37\u00B0C / 15 min", x: 300, y: 280,
                          data: { mode: "Automatic", variable: "TEMP", interpolation: "Linear", unit: "min", points: [{t:0,v:25},{t:15,v:37}] } },
                        { id: "w1", type: "wait", title: "Wait 45 min", sub: "Dur\u00E9e 45 min", x: 580, y: 190, data: { mode: "Automatic", duration: 45, unit: "min" } },
                        { id: "e1", type: "end", title: "End", sub: "", x: 820, y: 200, data: { mode: "Automatic" } },
                      ],
                      edges: [
                        { id: "e1a", from: "s1", to: "p1" },
                        { id: "e1b", from: "s1", to: "pf1" },
                        { id: "e2a", from: "p1", to: "w1" },
                        { id: "e2b", from: "pf1", to: "w1" },
                        { id: "e3a", from: "w1", to: "e1" },
                      ]
                    },
                    {
                      id: "inoc", name: "Inoculation",
                      nodes: [
                        { id: "is1", type: "start", title: "Start", sub: "", x: 80, y: 200, data: { mode: "Automatic" } },
                        { id: "iop", type: "operator", title: "Inoculate", sub: "Semi-Automatic", x: 300, y: 190, data: { mode: "Semi-Automatic", decisions: ["OK"], message: "Inoculer le bior\u00E9acteur" } },
                        { id: "ie1", type: "end", title: "End", sub: "", x: 560, y: 200, data: { mode: "Automatic" } },
                      ],
                      edges: [
                        { id: "ie1a", from: "is1", to: "iop" },
                        { id: "ie2a", from: "iop", to: "ie1" },
                      ]
                    },
                    {
                      id: "batch", name: "Batch",
                      nodes: [
                        { id: "bs1", type: "start", title: "Start", sub: "", x: 80, y: 200, data: { mode: "Automatic" } },
                        { id: "bw1", type: "wait", title: "Wait 1 min", sub: "Dur\u00E9e 1 min", x: 280, y: 190, data: { mode: "Automatic", duration: 1, unit: "min" } },
                        { id: "bp1", type: "parameter", title: "Activate pO2 control", sub: "pO2 35%", x: 500, y: 130,
                          data: { mode: "Automatic", parameters: ["pO2.State=remote","pO2.Mode=auto","pO2.Setpoint=35"] } },
                        { id: "be1", type: "end", title: "End", sub: "", x: 740, y: 200, data: { mode: "Automatic" } },
                      ],
                      edges: [
                        { id: "be1a", from: "bs1", to: "bw1", condition: "pO2.Value < 35%" },
                        { id: "be2a", from: "bw1", to: "bp1", condition: "pO2.Value < 35%" },
                        { id: "be3a", from: "bw1", to: "bw1", condition: "pO2.Value >= 35%" },
                        { id: "be4a", from: "bp1", to: "be1" },
                      ]
                    }
                  ]
                }
              ]
            },
            "test-pH7.2": {
              parentBranch: "main",
              parentVersion: "2.0",
              versions: [
                {
                  ver: "2.0-pH", date: "2026-01-13", author: "Nicolas", status: "draft",
                  message: "Variante: test pH 7.2 au lieu de 6.8",
                  operations: [
                    {
                      id: "prep", name: "Preparation",
                      nodes: [
                        { id: "s1", type: "start", title: "Start", sub: "", x: 80, y: 200, data: { mode: "Automatic" } },
                        { id: "p1", type: "parameter", title: "Set temperature and pH", sub: "TEMP 37\u00B0C \u00B7 pH 7.2", x: 300, y: 190,
                          data: { mode: "Automatic", parameters: ["TEMP.State=remote","TEMP.Mode=auto","TEMP.Setpoint=37","pH.State=remote","pH.Mode=auto","pH.Setpoint=7.2"] } },
                        { id: "w1", type: "wait", title: "Wait 30 min", sub: "Dur\u00E9e 30 min", x: 560, y: 190, data: { mode: "Automatic", duration: 30, unit: "min" } },
                        { id: "e1", type: "end", title: "End", sub: "", x: 800, y: 200, data: { mode: "Automatic" } },
                      ],
                      edges: [
                        { id: "e1a", from: "s1", to: "p1" },
                        { id: "e2a", from: "p1", to: "w1" },
                        { id: "e3a", from: "w1", to: "e1" },
                      ]
                    },
                    {
                      id: "inoc", name: "Inoculation",
                      nodes: [
                        { id: "is1", type: "start", title: "Start", sub: "", x: 80, y: 200, data: { mode: "Automatic" } },
                        { id: "iop", type: "operator", title: "Inoculate", sub: "Semi-Automatic", x: 300, y: 190, data: { mode: "Semi-Automatic", decisions: ["OK"], message: "Inoculer le bior\u00E9acteur" } },
                        { id: "ie1", type: "end", title: "End", sub: "", x: 560, y: 200, data: { mode: "Automatic" } },
                      ],
                      edges: [
                        { id: "ie1a", from: "is1", to: "iop" },
                        { id: "ie2a", from: "iop", to: "ie1" },
                      ]
                    },
                    {
                      id: "batch", name: "Batch",
                      nodes: [
                        { id: "bs1", type: "start", title: "Start", sub: "", x: 80, y: 200, data: { mode: "Automatic" } },
                        { id: "bw1", type: "wait", title: "Wait 1 min", sub: "Dur\u00E9e 1 min", x: 280, y: 190, data: { mode: "Automatic", duration: 1, unit: "min" } },
                        { id: "bp1", type: "parameter", title: "Activate pO2 control", sub: "pO2 35%", x: 500, y: 130,
                          data: { mode: "Automatic", parameters: ["pO2.State=remote","pO2.Mode=auto","pO2.Setpoint=35"] } },
                        { id: "be1", type: "end", title: "End", sub: "", x: 740, y: 200, data: { mode: "Automatic" } },
                      ],
                      edges: [
                        { id: "be1a", from: "bs1", to: "bw1", condition: "pO2.Value < 35%" },
                        { id: "be2a", from: "bw1", to: "bp1", condition: "pO2.Value < 35%" },
                        { id: "be3a", from: "bw1", to: "bw1", condition: "pO2.Value >= 35%" },
                        { id: "be4a", from: "bp1", to: "be1" },
                      ]
                    }
                  ]
                }
              ]
            }
          }
        }
      };

      // --- Diff state (moved above, before bindEvents/renderAll) ---

      function computeDiff(oldOp, newOp) {
        diffState.diffMap.clear();
        if (!oldOp || !newOp) return;
        const oldById = new Map(oldOp.nodes.map(n => [n.id, n]));
        const newById = new Map(newOp.nodes.map(n => [n.id, n]));
        for (const [id, newNode] of newById) {
          const oldNode = oldById.get(id);
          if (!oldNode) {
            diffState.diffMap.set(id, { status: "added", desc: "Nouvelle phase" });
          } else {
            const changes = [];
            if (oldNode.title !== newNode.title) changes.push(`"${oldNode.title}" \u2192 "${newNode.title}"`);
            if (oldNode.sub !== newNode.sub) changes.push(`${oldNode.sub || "(vide)"} \u2192 ${newNode.sub || "(vide)"}`);
            if (JSON.stringify(oldNode.data) !== JSON.stringify(newNode.data)) {
              if (oldNode.data?.mode !== newNode.data?.mode) changes.push(`Mode: ${oldNode.data?.mode} \u2192 ${newNode.data?.mode}`);
              const op1 = (oldNode.data?.parameters || []).join(", ");
              const op2 = (newNode.data?.parameters || []).join(", ");
              if (op1 !== op2) changes.push("Param\u00E8tres modifi\u00E9s");
              if (oldNode.data?.duration !== newNode.data?.duration) changes.push(`Dur\u00E9e: ${oldNode.data?.duration} \u2192 ${newNode.data?.duration}`);
            }
            diffState.diffMap.set(id, changes.length ? { status: "modified", desc: changes.join(" | ") } : { status: "unchanged", desc: "" });
          }
        }
        for (const [id, oldNode] of oldById) {
          if (!newById.has(id)) diffState.diffMap.set(id, { status: "removed", desc: `Phase supprim\u00E9e: "${oldNode.title}"` });
        }
      }

      function enterDiffWithVersions(oldOps, newOps, oldLabel, newLabel) {
        diffState.oldOps = JSON.parse(JSON.stringify(oldOps));
        diffState.newOps = JSON.parse(JSON.stringify(newOps));
        diffState.oldLabel = oldLabel;
        diffState.newLabel = newLabel;

        const curOpId = state.currentOpId;
        const oldOp = diffState.oldOps.find(o => o.id === curOpId);
        const newOp = diffState.newOps.find(o => o.id === curOpId);
        computeDiff(oldOp, newOp);

        diffState.active = true;
        document.body.classList.add("diffMode");
        byId("diffOldLabel").textContent = oldLabel;
        byId("diffNewLabel").textContent = newLabel;
        renderCanvas();
        syncSelection();
        renderDiffSummary();
      }

      function enterDiffMode() {
        // Use version store if available
        const store = versionStore[state.recipeId];
        if (store) {
          const branch = store.branches[store.currentBranch];
          if (branch && branch.versions.length >= 2) {
            const vs = branch.versions;
            const oldV = vs[vs.length - 2];
            const newV = vs[vs.length - 1];
            enterDiffWithVersions(oldV.operations, newV.operations,
              `v${oldV.ver} (${oldV.author})`, `v${newV.ver} (${newV.author})`);
            return;
          }
        }
        // Fallback: compare with undo history
        diffState.newOps = JSON.parse(JSON.stringify(state.operations));
        if (state.history.length > 0) {
          const snap = JSON.parse(state.history[state.history.length - 1]);
          diffState.oldOps = snap.operations;
          diffState.oldLabel = "Pr\u00E9c\u00E9dent"; diffState.newLabel = "Actuel";
        } else {
          diffState.oldOps = JSON.parse(JSON.stringify(state.operations));
          diffState.oldLabel = "(identique)"; diffState.newLabel = "Actuel";
        }
        const curOpId = state.currentOpId;
        computeDiff(
          diffState.oldOps.find(o => o.id === curOpId),
          diffState.newOps.find(o => o.id === curOpId)
        );
        diffState.active = true;
        document.body.classList.add("diffMode");
        byId("diffOldLabel").textContent = diffState.oldLabel;
        byId("diffNewLabel").textContent = diffState.newLabel;
        renderCanvas(); syncSelection(); renderDiffSummary();
      }

      function exitDiffMode() {
        diffState.active = false;
        diffState.diffMap.clear();
        document.body.classList.remove("diffMode");
        renderCanvas(); syncSelection();
      }

      function renderDiffSummary() {
        const list = byId("diffSummaryList");
        const stats = byId("diffSummaryStats");
        const opLabel = byId("diffSummaryOp");
        list.innerHTML = "";
        const op = getCurrentOp();
        if (opLabel && op) opLabel.textContent = op.name;
        let nA = 0, nR = 0, nM = 0;
        const items = [];
        for (const [id, info] of diffState.diffMap) {
          if (info.status === "unchanged") continue;
          if (info.status === "added") nA++;
          if (info.status === "removed") nR++;
          if (info.status === "modified") nM++;
          const node = op ? findNode(op, id) : null;
          let name = node ? node.title : id;
          if (info.status === "removed") {
            const oldOp = diffState.oldOps?.find(o => o.id === state.currentOpId);
            const oldNode = oldOp?.nodes.find(n => n.id === id);
            if (oldNode) name = oldNode.title;
          }
          items.push({ id, name, status: info.status, desc: info.desc });
        }
        items.forEach(c => {
          const cls = c.status === "added" ? "a" : c.status === "removed" ? "r" : "m";
          const lbl = c.status === "added" ? "+" : c.status === "removed" ? "\u2212" : "\u0394";
          const div = document.createElement("div");
          div.className = "dsItem";
          div.innerHTML = `<div class="dsIcon ${cls}">${lbl}</div><div><div class="dsName">${escapeHtml(c.name)}</div>${c.desc ? `<div class="dsDesc">${escapeHtml(c.desc)}</div>` : ""}</div>`;
          list.appendChild(div);
        });
        if (stats) {
          stats.innerHTML = "";
          if (nA) stats.innerHTML += `<span class="sa">+${nA} ajout${nA>1?"s":""}</span>`;
          if (nR) stats.innerHTML += `<span class="sr">\u2212${nR} suppr.</span>`;
          if (nM) stats.innerHTML += `<span class="sm">${nM} modif.</span>`;
          if (!nA && !nR && !nM) stats.innerHTML = `<span style="color:var(--muted);">Aucun changement</span>`;
        }
      }

      // --- Version History Panel --- (histState moved above, before bindEvents/renderAll)

      function openHistory() {
        histState.checked.clear();
        const store = versionStore[state.recipeId];
        const backdrop = byId("historyBackdrop");
        byId("historyTitle").textContent = `Historique \u2014 ${recipeCatalog.find(r=>r.id===state.recipeId)?.name || state.recipeId}`;

        // Populate branch selector
        const sel = byId("histBranchSelect");
        sel.innerHTML = "";
        if (store) {
          for (const bName of Object.keys(store.branches)) {
            const opt = document.createElement("option");
            opt.value = bName;
            opt.textContent = bName === "main" ? "main (principal)" : bName;
            if (bName === store.currentBranch) opt.selected = true;
            sel.appendChild(opt);
          }
        } else {
          sel.innerHTML = `<option>main</option>`;
        }

        renderHistoryVersions();
        backdrop.classList.add("active");
        updateModalLock();
      }

      function closeHistory() {
        byId("historyBackdrop").classList.remove("active");
        updateModalLock();
      }

      function renderHistoryVersions() {
        const list = byId("histVersionList");
        list.innerHTML = "";
        const store = versionStore[state.recipeId];
        if (!store) {
          list.innerHTML = `<div style="padding:20px;text-align:center;color:var(--muted);">Pas d'historique pour cette recette</div>`;
          return;
        }
        const branchName = byId("histBranchSelect").value || store.currentBranch;
        const branch = store.branches[branchName];
        if (!branch) return;

        // Show branch info
        const info = byId("histBranchInfo");
        if (branch.parentBranch) {
          info.textContent = `Branch\u00E9e depuis ${branch.parentBranch} @ v${branch.parentVersion}`;
        } else {
          info.textContent = `${branch.versions.length} version${branch.versions.length > 1 ? "s" : ""}`;
        }

        // Determine which version is currently loaded (latest on branch by default)
        const currentVer = store._loadedVer || branch.versions[branch.versions.length - 1]?.ver;

        // Render versions (newest first) with timeline rail
        const sorted = [...branch.versions].reverse();
        sorted.forEach((v, i) => {
          const div = document.createElement("div");
          const isCur = v.ver === currentVer;
          div.className = "histItem" + (histState.checked.has(v.ver) ? " selected" : "") + (isCur ? " isCurrent" : "");
          const statusLabel = { approved: "Approuv\u00E9e", locked: "Verrouill\u00E9e", draft: "Brouillon", review: "En revue" }[v.status] || v.status;
          div.innerHTML = `
            <input type="checkbox" class="histCheck" data-ver="${escapeHtml(v.ver)}" ${histState.checked.has(v.ver) ? "checked" : ""} />
            <div class="histRail"><div class="histDot ${v.status}"></div></div>
            <div class="histBody">
              <div class="histVer">
                v${escapeHtml(v.ver)}
                <span class="histStatus ${v.status}">${statusLabel}</span>
                <span class="histCurrentBadge">actuel</span>
              </div>
              <div class="histMsg">${escapeHtml(v.message)}</div>
              <div class="histMeta">
                <span class="histAuthor">${escapeHtml(v.author)}</span>
                <span>${escapeHtml(v.date)}</span>
              </div>
            </div>
            <div class="histActions">
              <button class="histRestoreBtn" data-ver="${escapeHtml(v.ver)}" title="Charger cette version">Charger</button>
            </div>
          `;

          const checkbox = div.querySelector(".histCheck");
          checkbox.addEventListener("change", () => {
            if (checkbox.checked) {
              if (histState.checked.size >= 2) {
                const first = histState.checked.values().next().value;
                histState.checked.delete(first);
              }
              histState.checked.add(v.ver);
            } else {
              histState.checked.delete(v.ver);
            }
            renderHistoryVersions();
          });

          const restoreBtn = div.querySelector(".histRestoreBtn");
          restoreBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            loadVersion(branchName, v.ver);
            closeHistory();
          });

          list.appendChild(div);
        });
      }

      function loadVersion(branchName, ver) {
        const store = versionStore[state.recipeId];
        if (!store) return;
        const branch = store.branches[branchName];
        if (!branch) return;
        const version = branch.versions.find(v => v.ver === ver);
        if (!version) return;

        saveHistory();
        state.operations = JSON.parse(JSON.stringify(version.operations));
        state.currentOpId = state.operations[0]?.id || "prep";
        state.selection = { nodeId: null, nodeIds: new Set() };
        store._loadedVer = ver;
        renderOperations();
        renderWorkspaceHeader();
        renderCanvas();
        syncSelection();
        persistSoon();
      }

      function compareCheckedVersions() {
        if (histState.checked.size !== 2) return;
        const store = versionStore[state.recipeId];
        if (!store) return;
        const branchName = byId("histBranchSelect").value || store.currentBranch;
        const branch = store.branches[branchName];
        if (!branch) return;

        const [verA, verB] = [...histState.checked];
        const vA = branch.versions.find(v => v.ver === verA);
        const vB = branch.versions.find(v => v.ver === verB);
        if (!vA || !vB) return;

        // Determine which is older
        const iA = branch.versions.indexOf(vA);
        const iB = branch.versions.indexOf(vB);
        const [oldV, newV] = iA < iB ? [vA, vB] : [vB, vA];

        // Load the new version into the editor first
        loadVersion(branchName, newV.ver);

        closeHistory();

        // Enter diff mode
        setTimeout(() => {
          enterDiffWithVersions(oldV.operations, newV.operations,
            `v${oldV.ver} (${oldV.author})`, `v${newV.ver} (${newV.author})`);
        }, 100);
      }

      function createBranch() {
        const store = versionStore[state.recipeId];
        if (!store) return;
        const name = prompt("Nom de la variante ?", "test-" + Date.now().toString(36).slice(-4));
        if (!name || store.branches[name]) return;

        const curBranch = byId("histBranchSelect").value || store.currentBranch;
        const branch = store.branches[curBranch];
        const lastVer = branch?.versions[branch.versions.length - 1];

        store.branches[name] = {
          parentBranch: curBranch,
          parentVersion: lastVer?.ver || "1.0",
          versions: [{
            ver: lastVer?.ver + "-" + name.slice(0, 8),
            date: new Date().toISOString().slice(0, 10),
            author: "Nicolas",
            status: "draft",
            message: `Variante depuis ${curBranch} v${lastVer?.ver}`,
            operations: JSON.parse(JSON.stringify(lastVer?.operations || state.operations))
          }]
        };

        // Switch to new branch
        store.currentBranch = name;
        byId("histBranchSelect").value = name;
        renderHistoryVersions();
        openHistory(); // refresh
      }

      // (diff overlay is now integrated directly in renderCanvas above)

      // WORKFLOW_UI_SCRIPT_END
    })();
  </script>
</body>
</html>
